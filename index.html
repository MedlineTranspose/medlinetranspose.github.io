<!DOCTYPE html>
<html>

<head>
<title>Medline Transpose</title>

	<!--Google Analytics -->
	<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-100696199-1', 'auto');
  ga('send', 'pageview');

	</script>
</head>

<link rel="stylesheet" href="w3.css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<meta name="viewport" content="width=device-width, initial-scale=1">

<style>
body,h1,h2,h3,h4,h5,h6 {font-family: "Lato", sans-serif}
.w3-navbar,h1,button {font-family: sans-serif}
.fa-anchor,.fa-coffee {font-size:200px}
</style>
<body>

<!-- Navbar -->
<div class="w3-top">
  <ul class="w3-navbar w3-blue-grey w3-card-2 w3-left-align w3-large">
    <li class="w3-hide-medium w3-hide-large w3-blue-grey w3-opennav w3-right">
      <a class="w3-padding-large w3-hover-white w3-large w3-blue-grey" href="javascript:void(0);" onClick="mySmallNav()" title="Toggle Navigation Menu"><i class="fa fa-bars"></i></a>
    </li>
    <li class="w3-hide-small"><a href="index.html" class="w3-padding-large w3-white">Home</a></li>
    <li class="w3-hide-small"><a href="about.html" class="w3-padding-large w3-hover-white">About</a></li>
    <li class="w3-hide-small"><a href="documentation.html" class="w3-padding-large w3-hover-white">Documentation</a></li>
  </ul>

  <!-- Navbar on small screens -->
  <div id="small-nav" class="w3-hide w3-hide-large w3-hide-medium">
    <ul class="w3-navbar w3-left-align w3-large w3-blue-grey">
      <li><a class="w3-padding-large" href="index.html">Home</a></li>
      <li><a class="w3-padding-large" href="about.html">About</a></li>
      <li><a class="w3-padding-large" href="documentation.html">Documentation</a></li>
    </ul>
  </div>
</div>

<!-- Header -->
<header class="w3-container w3-blue-grey w3-center w3-padding-64">
	<h1 class="w3-margin w3-jumbo">Medline Transpose</h1>
	<p class="w3-xlarge">Translate a search query between Ovid MEDLINE and PubMed syntax</p>
</header>

<!-- Beta testing link -->
<div class="w3-container w3-yellow w3-topbar w3-bottombar w3-border-amber">
  <span onclick="this.parentElement.style.display='none'" class="w3-closebtn">&times;</span>
  <p><b>MEDLINE Transpose is still being tested, so there may be mistakes or errors. Please help us improve it <a href="https://goo.gl/forms/QmwV2TGarYrocVay2." target="_blank">by taking a short survey.</b></a></p>
</div>
</div>

<!-- Body -->
<div class="w3-row-padding w3-theme-l4 w3-container">
  <div class="w3-content">

	<!-- Search Input -->
    <div class="w3-container">
    	<b><p class="w3-xlarge">Enter your search strategy</p></b>

		<!-- accordion -->
		<div class="w3-accordion">
			<button onClick="myAccordion('Ovid-Acc')" class="w3-btn w3-round-large w3-theme">
			Ovid Example
			</button>
			<div id="Ovid-Acc" class="w3-accordion-content w3-container">
				<p><b>Try pasting the following into the box below, then select "Ovid to PubMed":</b></p>
				<p>anxiety, separation/th or exp "attention deficit and disruptive behavior disorders"/<br>
				separation anxiety.ti,ab<br>
				(ADD or ADHD).ti,ab<br>
				Cognitive Therapy/ <br>
				exp Mind-Body Therapies/<br>
				or/1-3<br>
				or/4-5<br>
				6 and 7</p>
			</div>

						  <div class="w3-padding-4">
				</div>
			<button onClick="myAccordion('PubMed-Acc')" class="w3-btn w3-round-large w3-theme">
			PubMed Example
			</button>
			<div id="PubMed-Acc" class="w3-accordion-content w3-container">
				<p><b>Try pasting the following into the box below, then select "PubMed to Ovid":</b></p>
				<p>"Brain Concussion"[Mesh] OR "Brain Injuries"[Mesh:NoExp] <br>
				"Depression"[Mesh] OR "Depressive Disorder"[Mesh] OR depress*[tiab]<br>
				#1 and #2<br>
				#3 and jsubsetaim[text]</p>
		</div>
			  <div class="w3-padding-8">
				</div>
	</div>

  <textarea class="w3-input w3-large w3-border w3-round-large" id="userEntry" value="Exercise Therapy/" required name="userInput" rows="7"></textarea>
	<div class="w3-layout-cell w3-layout-middle">
    	<input id="ovid" class="w3-radio" type="radio" name="database" value="OTP">
    	<label class="w3-validate">Ovid to PubMed</label>
    	<br>
    	<input id="pubmed" class="w3-radio" type="radio" name="database" value="PTO">
    	<label class="w3-validate">PubMed to Ovid</label>
    	<br><br>
  	</div>

	<div class="w3-layout-cell w3-layout-middle">
    	<input id="accuracy" class="w3-radio" type="radio" name="preference" value="accuracy">
    	<label class="w3-validate">Accuracy</label>
    	<br>
    	<input id="efficiency" class="w3-radio" type="radio" name="preference" value="efficiency">
    	<label class="w3-validate">Efficiency</label>
    	<br><br>
  	</div>

	<div class="w3-container w3-layout-cell w3-layout-middle">
		<button class="w3-btn w3-padding-large w3-round-large w3-theme" id="submit" onClick="myFunction()">Submit</button></p>
	</div>

	  <div class="w3-padding-8">
  	</div>

  </div>
</div>
</div>


<!-- Search results -->
<div class="w3-container w3-theme-l2 w3-padding-8">
  <!-- anchor link to results -->
  <a name = "results"></a>
	<div class="w3-content">
      <!-- Search Results -->
			<b><p class="w3-xlarge">Results</p></b>
				<!-- results -->
			<div class="w3-large">
				<p id="output2"></p>
				<p id="output3"></p>
				<!-- warnings -->
				<p id="output4"></p>
				<!-- testing -->
				<p id="output5"></p>
				<br><br>
			</div>
	</div>
</div>

<!-- Footer -->
<footer class="w3-row-padding w3-container w3-padding-32 w3-center">
	<div class="w3-xlarge w3-padding-32">
		<h1 class="w3-margin w3-xlarge w3-opacity">This project was made possible by</h1>
		<div class="w3-layout-container">
		<div class="w3-container w3-layout-cell">
		<img src="CLAHRC-logo-1.jpg" alt="Plymouth University Peninsula Schools of Medicine & Dentistry" class="w3-image">
		</div>
		<div class="w3-container w3-layout-cell">
		<img src="CLAHRC-logo-2.jpg" alt="NIHR CLAHRC South West Peninsula" class="w3-image">
		</div>
		<div class="w3-container w3-layout-cell">
		<img src="CPSBC-logo.jpg" alt="College of Physicians and Surgeons of British Columbia" class="w3-image">
		</div>
		</div>
 	</div>
		<p>Powered by <a href="http://www.w3schools.com/w3css/default.asp" target="_blank">w3.css</a></p>
</footer>

<script>

//**************************************************************Functions start***********************************

function mySmallNav() {
    var x = document.getElementById("small-nav");
    if (x.className.indexOf("w3-show") == -1) {
        x.className += " w3-show";
    } else {
        x.className = x.className.replace(" w3-show", "");
    }
}

function myAccordion(id) {
    var x = document.getElementById(id);
    if (x.className.indexOf("w3-show") == -1) {
        x.className += " w3-show";
    } else {
        x.className = x.className.replace(" w3-show", "");
    }
}

function myFunction() {

	var rb1 = document.getElementById("ovid");
	var rb2 = document.getElementById("pubmed");
	var mfInputline = document.getElementById("userEntry").value;
	var warnOTP = "Are you sure that you meant Ovid to PubMed? I see PubMed syntax in your entry.";
  	var warnPTO = "Are you sure that you meant PubMed to Ovid? I see Ovid syntax in your entry";
	var warnNoChoice = "Please make a selection: Ovid to PubMed or PubMed to Ovid";
  	warnOTP = warnOTP.fontcolor("maroon");
  	warnPTO = warnPTO.fontcolor("maroon");
	warnNoChoice = warnNoChoice.fontcolor("maroon");
	var prefRB1 = document.getElementById("accuracy");
	var prefRB2 = document.getElementById("efficiency");
	var userPref = 0;

	if (prefRB1.checked){
		userPref = 0;
	}
	else if (prefRB2.checked){
		userPref = 1;
	}

    if (rb1.checked && rb2.checked == false){
	if (mfInputline.search(/\[/i) >= 0 && mfInputline.search(/\]/i) >= 0){
          document.getElementById("output5").innerHTML = warnOTP;
        }
        else{
          document.getElementById("output5").innerHTML = "";
        }
    	transposeOTP(mfInputline, userPref);
    }
    else if (rb1.checked == false && rb2.checked){
	if (mfInputline.search(/exp/i) >= 0 && mfInputline.search(/\//i) >= 0){
          document.getElementById("output5").innerHTML = warnPTO;
        }
        else if (mfInputline.search(/[.]\w\w[.]/) >= 0 && mfInputline.search(/[.]\d\d[.]/) < 0){
          document.getElementById("output5").innerHTML = warnPTO;
        }
        else{
          document.getElementById("output5").innerHTML = "";
        }
      	transposePTO(mfInputline, userPref);
    }
	else if (rb1.checked == false && rb2.checked == false){
	    document.getElementById("output5").innerHTML = warnNoChoice;
	}

  // anchor link to results section
  window.location.hash = '';
  window.location.hash = 'results';
}

function transposeOTP(inputline, uPref){

    //read in the user input (Ovid search strategy)
    //var inputline = document.getElementById("userEntry").value;
    //document.getElementById("output0").innerHTML = inputline;
    var outputline = "blank";

    // warnings array
    var warningArray = [];
    var warningIndex = 0;
		var wi = 0;
    var wiPlus = 1;

	var numCloseParens = 0;
	var totalCloseParens = 0;
	var numOpenParens = 0;
	var totalOpenParens = 0;

	var range = [];
	var operator = "";
	var start = null;
	var end = null;
	var rangeString = "";
	var p = null;

	// testing array
	var testingArray = [null, null];
	var testingIndex = 0;

    //make an array to receive the output of other functions and split it into output and warnings
    var outputReceiver = [null, null];

	// convert adj to AND
	if (inputline.search(/adj\d?/i) >= 0 ) {
		inputline = inputline.replace(/adj\d?/ig,"AND");
		warningArray.push("PubMed does not support the use of adjacency. Converted ADJ to AND."); // warning message
		warningIndex++;
	}
	else {
		// do nothing
	}

	  //look for MeSH terms containing boolean operators
  if (inputline.search(/"[\w\s]* and [\w\s]*"[ \/\.]+/ig) >= 0){
    inputline = inputline.replace(/("[\w\s]*) and ([\w\s]*"[ \/\.]+)/ig, "$1 GRRRAND $2");
  }
  if (inputline.search(/"[\w\s]* or [\w\s]*"[ \/\.]+/i) >= 0){
    inputline = inputline.replace(/("[\w\s]*) or ([\w\s]*"[ \/\.]+)/ig, "$1 ARRGHOR $2");
  }
  if (inputline.search(/"[\w\s]* not [\w\s]*"[ \/\.]+/i) >= 0){
		inputline = inputline.replace(/("[\w\s]*) not ([\w\s]*"[ \/\.]+)/ig, "$1 SERENOTY $2");
  }

// split user input based on line breaks
var lineBreakArray = inputline.split(/[\n\r]/);
var lineBreakCounter = lineBreakArray.length - 1;
var lineBreakLength = lineBreakArray.length;
for (s = lineBreakCounter; s >= 0; s--) {

// placeholer
//look for limits containing boolean operators
if (lineBreakArray[s].search(/limit [\d]+ to/i) >= 0){
	lineBreakArray[s] = lineBreakArray[s].replace(/ and /ig, " GRRRAND ");
	lineBreakArray[s] = lineBreakArray[s].replace(/ or /ig, " ARRGHOR ");
	lineBreakArray[s] = lineBreakArray[s].replace(/ not /ig, " SERENOTY ");
}

	// look for or/1-3 syntax construction
	if (lineBreakArray[s].search(/(or|and|not)\/([\d]+)-([\d]+)/i) >= 0){
		operator = lineBreakArray[s].replace(/(or|and|not)\/([\d]+)-([\d]+)/,"$1");
		start = parseInt(lineBreakArray[s].replace(/(or|and|not)\/([\d]+)-([\d]+)/,"$2"));
		end = parseInt(lineBreakArray[s].replace(/(or|and|not)\/([\d]+)-([\d]+)/,"$3"));

			// expand range into individual numbers
			for (var p = start; p <= end; p++) {
					range.push(p);
			}

			// join range with boolean operator
			var rangeString = range.join(".number " + operator + " "); // temporary field code
					rangeString = rangeString + ".number"; // temporary field code
					lineBreakArray[s] = rangeString;
	}
	range = []; // clear range array

    //split user input by any OR operators and put the pieces into an array
  var orArray = lineBreakArray[s].split(/ OR /i);
	var orLengthCounter = orArray.length - 1; // for nested parenthasis
  var orLength = orArray.length;
	var mostRecentTag = "";

		// or loop
		for (i = orLengthCounter; i >= 0; i--){

            //split the string by any AND operators and put the pieces into an array
            var andArray = orArray[i].split(/ AND /i);
						var andLengthCounter = andArray.length - 1; // for nested parenthasis
            var andLength = andArray.length;

				// and loop
				for (j = andLengthCounter; j >= 0; j--){

                	//split the string by any NOT operators and put the pieces into an array
                    var notArray = andArray[j].split(/ NOT /i);
										var notLengthCounter = notArray.length - 1; // for nested parenthasis
                    var notLength = notArray.length;

					// not loop
					for (k = notLengthCounter; k >= 0; k--){

						// is it a limit?
						if (notArray[k].search(/limit [\d]+ to/i) >= 0) {
							outputReceiver = formatLimitOTP(notArray[k]);
							notArray[k] = outputReceiver[0];
							// testingArray[testingIndex] = notArray[k]
							warningArray[warningIndex] = outputReceiver[1];
						} // end limits

            // is it a MeSH term?
            else if (notArray[k].search(/\//) >= 0){
							outputReceiver = formatMesh(notArray[k]);
							notArray[k] = outputReceiver[0];
							warningArray[warningIndex] = outputReceiver[1];
          	} // end mesh

            // is it a keyword?
            else {
							// if a regular keyword
							if (notArray[k].search(/\./) >= 0) { //
								var mostRecentTagArray = notArray[k].match(/\.[ a-zA-Z,\/.]+$/);
								mostRecentTag = mostRecentTagArray[0]; // mostRecentTag = keyword field code
							}

						// if no field codes
						if (mostRecentTag == "") {
							// if a number
							if (notArray[k].search(/^[\(\s]*[\d]+[\s\)]*/) >= 0) { // search for numbers
								notArray[k] = notArray[k] + ".number";
							}
							// otherwise give it an all fields tag
							else {
								warningArray.push("For any terms without field codes, the All Fields [all] code has been applied.");
								warningIndex++;
								notArray[k] = addQuotes(notArray[k]);
								notArray[k] = notArray[k] + ".af";
							}
						}

						// ensure parenthasis aren't screwed up
						if (notArray[k].search(/[)]/) > 0) {
							numCloseParens = notArray[k].match(/[)]/g).length;
						}

						if (numCloseParens != null){
							totalCloseParens = totalCloseParens + numCloseParens;
						}

						if (notArray[k].search(/[(]/) > 0) {
							numOpenParens = notArray[k].match(/[(]/g).length;
						}

						if (numOpenParens != null){
							totalOpenParens = totalOpenParens + numOpenParens;
						}

						if (totalOpenParens >= totalCloseParens) {
							notArray[k] = notArray[k] + mostRecentTag;
							mostRecentTag = "";
							totalOpenParens = 0;
							totalCloseParens = 0;
						}
						else{
							if (notArray[k].search(/\.[a-zA-Z, ]+/) >= 0) {
								// do nothing
							}
							else {
								notArray[k] = notArray[k] + mostRecentTag;
							}
						}

						// all keyword processing
						outputReceiver = formatKeyword(notArray[k], uPref);
						notArray[k] = outputReceiver[0];
						warningArray[warningIndex] = outputReceiver[1];
					} // end keywords

            warningIndex++;
					testingIndex++;

				} // notLengthCounter
                andArray[j] = notArray.join(" NOT ");
			} // andLengthCounter
            orArray[i] = andArray.join(" AND ");
		} // orLengthCounter
        lineBreakArray[s] = orArray.join(" OR ");
				// deal with blank lines
				if (lineBreakArray[s].search(/^[" ]*\[all\]/i) >= 0) {
					lineBreakArray[s] = "";
				}
	} // lineBreakCounter
			outputline = lineBreakArray.join("<br />");

  // split values in warningArray based on |, put into one total array
  var m = null;
  var n = null;
  var warningArrayClean = [];
  for (m = 0; m < warningArray.length; m++) {
    if (warningArray[m].search("|") >= 0) { // if contains |
      var arr = warningArray[m].split("|");
      for (n = 0; n < arr.length; n++) {
        // push all split values into warningArrayClean
        warningArrayClean.push(arr[n]);
      }
    }
    else // add value to warningArrayClean
      warningArrayClean.push(warningArray[m]);
  }

  // remove duplicates from warningArrayClean
  var uniqWarningArray = [...new Set(warningArrayClean)];

  // warning array into a string for output
	var warningString = uniqWarningArray.join("<p>");

	  if (outputline.search(/GRRRAND/i) >= 0){
    outputline = outputline.replace(/GRRRAND/ig, " AND ");
  }
  if (outputline.search(/ARRGHOR/i) >= 0){
    outputline = outputline.replace(/ARRGHOR/ig, " OR ");
  }
  if (outputline.search(/SERENOTY/i) >= 0){
    outputline = outputline.replace(/SERENOTY/ig, " NOT ");
  }

	document.getElementById("output3").innerHTML = outputline;
  document.getElementById("output4").innerHTML = warningString;
	// document.getElementById("output5").innerHTML = testingArray;

}  // this corresponds to the function declaration

// ****************************************** MESH ******************************************
function formatMesh (fmString) {

    // make a variable to hold any warnings
    var fmWarningArray = [null, null];

    // make an array to hold the outputs (string and warnings)
    var fmOutputArray = [null, null];

    var tempArray = [];
    var subHeadingArray2 = [];

    var c;
	  var i;
    var j;
	  var k;
    var l;
	  var z;

    // subheadings
  var subHeadingList = ["Abnormalities", "Administration and Dosage", "Adverse Effects", "Agonists", "Analogs and Derivatives", "Analysis", "Anatomy and Histology", "Antagonists and Inhibitors", "Biosynthesis", "Blood Supply", "Blood", "Cerebrospinal Fluid", "Chemical Synthesis", "Chemically Induced", "Chemistry", "Classification", "Complications", "Congenital", "Contraindications", "Cytology", "Deficiency", "Diagnosis", "Diagnostic Use", "Diet Therapy", "Diagnostic Imaging", "Drug Effects", "Drug Therapy", "Economics", "Education", "Embryology", "Enzymology", "Epidemiology", "Ethics", "Ethnology", "Etiology", "Genetics", "Growth and Development", "History", "Immunology", "Injuries", "Innervation", "Instrumentation", "Isolation and Purification", "Legislation and Jurisprudence", "Manpower", "Metabolism", "Methods", "Microbiology", "Mortality", "Nursing", "Organization and Administration", "Parasitology", "Pathogenicity", "Pathology", "Pharmacokinetics", "Pharmacology", "Physiology", "Physiopathology", "Poisoning", "Prevention and Control", "Psychology", "Radiation Effects", "Radiotherapy", "Rehabilitation", "Secondary", "Secretion", "Standards", "Statistics and Numerical Data", "Supply and Distribution", "Surgery", "Therapeutic Use", "Therapy", "Toxicity", "Transmission", "Transplantation", "Trends", "Ultrastructure", "Urine", "Utilization", "Veterinary", "Virology"];
	var subHeadingCode = ["AB", "AD", "AE", "AG", "AA", "AN", "AH", "AI", "BI", "BS", "BL", "CF", "CS", "CI", "CH", "CL", "CO", "CN", "CT", "CY", "DF", "DI","DU", "DH", "DG", "DE", "DT", "EC", "ED", "EM", "EN", "EP", "ES", "EH", "ET", "GE", "GD", "HI", "IM", "IN", "IR", "IS", "IP", "LJ", "MA", "ME", "MT", "MI", "MO", "NU", "OG", "PS", "PY", "PA", "PK", "PD", "PH", "PP", "PO", "PC", "PX", "RE", "RT", "RH", "SC", "SE", "ST", "SN", "SD", "SU", "TU", "TH", "TO", "TM", "TR", "TD", "UL", "UR", "UT", "VE", "VI"];
	var subHeadingExplode = ["AN", "AH", "CY", "EM", "CH", "DI", "ET", "CO", "MI", "OG", "PD", "AE", "PH", "ME", "SN", "EP", "TU", "TH", "SU"];

	// publication types
	var pubType = ["addresses", "autobiography", "bibliography", "biography", "case reports", "classical article", "clinical conference", "clinical study", "clinical trial", "clinical trial, phase i", "clinical trial, phase ii", "clinical trial, phase iii", "clinical trial, phase iv", "collected works", "comparative study", "congresses", "consensus development conference", "consensus development conference, nih", "controlled clinical trial", "dataset", "dictionary", "directory", "duplicate publication", "editorial", "english abstract", "evaluation studies", "festschrift", "government publications", "guideline", "historical article", "interactive tutorial", "interview", "introductory journal article", "journal article", "lectures", "legal cases", "legislation", "letter", "meta-analysis", "meta analysis", "multicenter study", "news", "newspaper article", "observational study", "overall", "patient education handout", "periodical index", "personal narratives", "portraits", "practice guideline", "pragmatic clinical trial", "publication components", "publication formats", "publication type category", "randomized controlled trial", "research support, american recovery and reinvestment act", "research support, n.i.h., extramural", "research support, n.i.h., intramural", "research support, non-u.s. gov't research support, u.s. gov't, non-p.h.s.", "research support, u.s. gov't, p.h.s.", "review", "scientific integrity review", "study characteristics", "support of research", "technical report", "twin study", "validation studies", "video-audio media", "webcasts"];

	// floating or exploded subheadings --> these are now handled in keyword processing. to delete.
    if (fmString.search(/\.fs/i) >= 0|fmString.search(/\.xs/i) >= 0) {
    	fmString = fmString.toUpperCase();
    	fmSubheadingArray = fmString.split(".");

    	for (c=0; c < subHeadingCode.length; c++) {
    		if (fmSubheadingArray[0] == subHeadingCode[c]) {
    			fmSubheadingArray[0] = fmSubheadingArray[0].replace(fmSubheadingArray[0],subHeadingList[c]);
    		}
    	}
    	if (fmSubheadingArray[1] == "FS") {
    		fmSubheadingArray[1] = "[sh:noexp]";
    	}
    	else if (fmSubheadingArray[1] == "XS") {
    		fmSubheadingArray[1] = "[sh]";
    	}
		fmSubheadingArray[0] = addQuotes(fmSubheadingArray[0]);
		fmString = fmSubheadingArray[0] + fmSubheadingArray[1];
		fmString = fmString.toLowerCase();
    } // end .fs and .xs processing


	// regular Mesh processing
	else {
		// containers to hold parts of the input string
 		var fmBeg = new RegExp(/^[\n\r (]*/); // matches anything before mesh
 		fmBeg = fmBeg.exec(fmString);

 		var fmMesh = new RegExp(/[\w, "()-]+(?=\/)/); // match the mesh term, incl "" and exp and *
 		fmMesh = fmMesh.exec(fmString);

 		var fmSubHead = new RegExp(/[\/][.,a-zA-Z ]*/); // matches subheadings and slash
 		fmSubHead = fmSubHead.exec(fmString);

 		var fmEnd = new RegExp(/[ )\r\n]*$/); // matches end parenthesis
 		fmEnd = fmEnd.exec(fmString);

 		var fmMeshType = ""; // to hold type of mesh

		// publication type processing
		for (i = 0; i < pubType.length; i++) {
			if (fmMesh[0].toLowerCase().search(pubType[i]) >= 0) {
				if (fmString.search(/exp /i) >= 0) {
					fmMeshType = "[pt]";
				}
				else {
					fmMeshType = "[pt:noexp]";
				}
			}
		}

		// mesh type processing
		if (fmMeshType.search(/pt/i) >= 0){
			// do nothing
		}
		else if (fmString.search(/\*/) >= 0 && fmString.search(/exp /i) >= 0){
			fmMeshType = "[majr]";
		}
		else if (fmString.search(/\*/) >= 0){
			fmMeshType = "[majr:noexp]";
		}
		else if (fmString.search(/exp /i) >= 0){
			fmMeshType = "[mesh]";
		}
		else {
			fmMeshType = "[mesh:noexp]";
		}

 		// format subheadings
  		if (fmSubHead[0].search(/[a-zA-Z]/) >= 0) { // if contains subheadings
				fmSubHead[0] = fmSubHead[0].replace(/[\s]*/g,""); // remove any white space
  			fmSubHead[0] = fmSubHead[0].toUpperCase(); // uppercase to match subheading code array above
				fmSubHead[0] = fmSubHead[0].replace(/[\/]/,""); // remove slash
  			var subHeadingArray = fmSubHead[0].split(","); // array of subheading codes from user input

  			// go through each subheading in array
			for (k=0; k < subHeadingArray.length; k++) {

				subHeadingArray[k] = subHeadingArray[k].replace(/\s/g,''); // remove any spaces

				// search for diagnostic use -- no longer used
				if (subHeadingArray[k].search("DU") >= 0) { // mesh contains subheading Diagnostic Use
					fmWarningArray.push("The subheading <b>Diagnostic Use</b> is no longer used. Remove it from your search or replace it with another subheading.");
				}

				// radiography subheading
				if (subHeadingArray[k].search("RA") >= 0) {
					subHeadingArray[k] = "DG";
					fmWarningArray.push("The subheading <b>Radiography</b> has been absorbed by Diagnostic Imaging. Term has been changed in search strategy. For more information, please see <a href='https://www.nlm.nih.gov/mesh/2017/download/2017QualifierChanges.pdf' target='_blank'>this page</a>.");
				}

				// radionuclide subheading
				if (subHeadingArray[k].search("RI") >= 0) {
					subHeadingArray[k] = "DG";
					fmWarningArray.push("The subheading <b>radionuclide</b> has been absorbed by Diagnostic Imaging. Term has been changed in search strategy. For more information, please see <a href='https://www.nlm.nih.gov/mesh/2017/download/2017QualifierChanges.pdf' target='_blank'>this page</a>.");
				}

				// ultrasonography subheading
				if (subHeadingArray[k].search("US") >= 0) {
					subHeadingArray[k] = "DG";
					fmWarningArray.push("The subheading <b>ultrasonographye</b> has been absorbed by Diagnostic Imaging. Term has been changed in search strategy. For more information, please see <a href='https://www.nlm.nih.gov/mesh/2017/download/2017QualifierChanges.pdf' target='_blank'>this page</a>.");
				}

				// if a match with exploded subheadings list
				for (l = 0; l < subHeadingExplode.length; l++) {

					if (subHeadingArray[k] == subHeadingExplode[l]) {
						if (fmMeshType.search("noexp") >= 0) { // mesh contains noexp
							// do nothing
						}
						else {
							switch (subHeadingArray[k]) {
								case "AN":
                  fmWarningArray.push("The subheading <b>" + subHeadingArray[k] + "</b> is automatically exploded in PubMed. In PubMed, this search will return more results because it will also search for the MeSH term <b>" +  fmMesh.toString().replace('exp ','').replace("GRRRAND","and").replace("ARRGHOR","or").replace("SERENOTY","not") + "</b> with the subheadings <b>BL, CF, IP, and UR.</b> For more information see <a href='https://www.nlm.nih.gov/mesh/subhierarchy.html' target='_blank'>this page</a>.");
									break;
								case "CY":
                  fmWarningArray.push("The subheading <b>" + subHeadingArray[k] + "</b> is automatically exploded in PubMed. In PubMed, this search will return more results because it will also search for the MeSH term <b>" +  fmMesh.toString().replace('exp ','').replace("GRRRAND","and").replace("ARRGHOR","or").replace("SERENOTY","not") + "</b> with the subheading <b>UL.</b> For more information see <a href='https://www.nlm.nih.gov/mesh/subhierarchy.html' target='_blank'>this page</a>.");
									break;
								case "EM":
                  fmWarningArray.push("The subheading <b>" + subHeadingArray[k] + "</b> is automatically exploded in PubMed. In PubMed, this search will return more results because it will also search for the MeSH term <b>" +  fmMesh.toString().replace('exp ','').replace("GRRRAND","and").replace("ARRGHOR","or").replace("SERENOTY","not") + "</b> with the subheading <b>AB.</b> For more information see <a href='https://www.nlm.nih.gov/mesh/subhierarchy.html' target='_blank'>this page</a>.");
									break;
								case "AH":
                  fmWarningArray.push("The subheading <b>" + subHeadingArray[k] + "</b> is automatically exploded in PubMed. In PubMed, this search will return more results because it will also search for the MeSH term <b>" +  fmMesh.toString().replace('exp ','').replace("GRRRAND","and").replace("ARRGHOR","or").replace("SERENOTY","not") + "</b> with the subheadings <b>AG, AA, AI, and CS.</b> For more information see <a href='https://www.nlm.nih.gov/mesh/subhierarchy.html' target='_blank'>this page</a>.");
									break;
								case "DI":
                  fmWarningArray.push("The subheading <b>" + subHeadingArray[k] + "</b> is automatically exploded in PubMed. In PubMed, this search will return more results because it will also search for the MeSH term <b>" +  fmMesh.toString().replace('exp ','').replace("GRRRAND","and").replace("ARRGHOR","or").replace("SERENOTY","not") + "</b> with the subheading <b>DG.</b> For more information see <a href='https://www.nlm.nih.gov/mesh/subhierarchy.html' target='_blank'>this page</a>.");
									break;
								case "CO":
                  fmWarningArray.push("The subheading <b>" + subHeadingArray[k] + "</b> is automatically exploded in PubMed. In PubMed, this search will return more results because it will also search for the MeSH term <b>" +  fmMesh.toString().replace('exp ','').replace("GRRRAND","and").replace("ARRGHOR","or").replace("SERENOTY","not") + "</b> with the subheading <b>SC.</b> For more information see <a href='https://www.nlm.nih.gov/mesh/subhierarchy.html' target='_blank'>this page</a>.");
									break;
								case "MI":
                  fmWarningArray.push("The subheading <b>" + subHeadingArray[k] + "</b> is automatically exploded in PubMed. In PubMed, this search will return more results because it will also search for the MeSH term <b>" +  fmMesh.toString().replace('exp ','').replace("GRRRAND","and").replace("ARRGHOR","or").replace("SERENOTY","not") + "</b> with the subheading <b>VI.</b> For more information see <a href='https://www.nlm.nih.gov/mesh/subhierarchy.html' target='_blank'>this page</a>.");
									break;
								case "ET":
                  fmWarningArray.push("The subheading <b>" + subHeadingArray[k] + "</b> is automatically exploded in PubMed. In PubMed, this search will return more results because it will also search for the MeSH term <b>" +  fmMesh.toString().replace('exp ','').replace("GRRRAND","and").replace("ARRGHOR","or").replace("SERENOTY","not") + "</b> with the subheadings <b>CI, CO, SC, CN, EM, GE, IM, MI, VI, PS, and TM.</b> For more information see <a href='https://www.nlm.nih.gov/mesh/subhierarchy.html' target='_blank'>this page</a>.");
									break;
								case "OG":
                  fmWarningArray.push("The subheading <b>" + subHeadingArray[k] + "</b> is automatically exploded in PubMed. In PubMed, this search will return more results because it will also search for the MeSH term <b>" +  fmMesh.toString().replace('exp ','').replace("GRRRAND","and").replace("ARRGHOR","or").replace("SERENOTY","not") + "</b> with the subheadings <b>EC, LJ, MA, ST, SD, TD, and UT.</b> For more information see <a href='https://www.nlm.nih.gov/mesh/subhierarchy.html' target='_blank'>this page</a>.");
									break;
								case "AE":
                  fmWarningArray.push("The subheading <b>" + subHeadingArray[k] + "</b> is automatically exploded in PubMed. In PubMed, this search will return more results because it will also search for the MeSH term <b>" +  fmMesh.toString().replace('exp ','').replace("GRRRAND","and").replace("ARRGHOR","or").replace("SERENOTY","not") + "</b> with the subheadings <b>PO and TO.</b> For more information see <a href='https://www.nlm.nih.gov/mesh/subhierarchy.html' target='_blank'>this page</a>.");
									break;
								case "PD":
                  fmWarningArray.push("The subheading <b>" + subHeadingArray[k] + "</b> is automatically exploded in PubMed. In PubMed, this search will return more results because it will also search for the MeSH term <b>" +  fmMesh.toString().replace('exp ','').replace("GRRRAND","and").replace("ARRGHOR","or").replace("SERENOTY","not") + "</b> with the subheadings <b>AD, AE, PO, TO, AG, AI, CT, and PK.</b> For more information see <a href='https://www.nlm.nih.gov/mesh/subhierarchy.html' target='_blank'>this page</a>.");
									break;
								case "ME":
                  fmWarningArray.push("The subheading <b>" + subHeadingArray[k] + "</b> is automatically exploded in PubMed. In PubMed, this search will return more results because it will also search for the MeSH term <b>" +  fmMesh.toString().replace('exp ','').replace("GRRRAND","and").replace("ARRGHOR","or").replace("SERENOTY","not") + "</b> with the subheadings <b>BI, BL, CF, DF, EN, PK, and UR.</b> For more information see <a href='https://www.nlm.nih.gov/mesh/subhierarchy.html' target='_blank'>this page</a>.");
									break;
								case "PH":
                  fmWarningArray.push("The subheading <b>" + subHeadingArray[k] + "</b> is automatically exploded in PubMed. In PubMed, this search will return more results because it will also search for the MeSH term <b>" +  fmMesh.toString().replace('exp ','').replace("GRRRAND","and").replace("ARRGHOR","or").replace("SERENOTY","not") + "</b> with the subheadings <b>GE GD, IM, ME, BI, BL, CF, DF, EN, PK, UR, PP, and SE.</b> For more information see <a href='https://www.nlm.nih.gov/mesh/subhierarchy.html' target='_blank'>this page</a>.");
									break;
								case "EP":
                  fmWarningArray.push("The subheading <b>" + subHeadingArray[k] + "</b> is automatically exploded in PubMed. In PubMed, this search will return more results because it will also search for the MeSH term <b>" +  fmMesh.toString().replace('exp ','').replace("GRRRAND","and").replace("ARRGHOR","or").replace("SERENOTY","not") + "</b> with the subheadings <b>EH and MO.</b> For more information see <a href='https://www.nlm.nih.gov/mesh/subhierarchy.html' target='_blank'>this page</a>.");
									break;
								case "SN":
                  fmWarningArray.push("The subheading <b>" + subHeadingArray[k] + "</b> is automatically exploded in PubMed. In PubMed, this search will return more results because it will also search for the MeSH term <b>" +  fmMesh.toString().replace('exp ','').replace("GRRRAND","and").replace("ARRGHOR","or").replace("SERENOTY","not") + "</b> with the subheadings <b>EP, EH, MO, SD, and UT.</b> For more information see <a href='https://www.nlm.nih.gov/mesh/subhierarchy.html' target='_blank'>this page</a>.");
									break;
								case "TU":
                  fmWarningArray.push("The subheading <b>" + subHeadingArray[k] + "</b> is automatically exploded in PubMed. In PubMed, this search will return more results because it will also search for the MeSH term <b>" +  fmMesh.toString().replace('exp ','').replace("GRRRAND","and").replace("ARRGHOR","or").replace("SERENOTY","not") + "</b> with the subheadings <b>AD, AE, CT, and PO.</b> For more information see <a href='https://www.nlm.nih.gov/mesh/subhierarchy.html' target='_blank'>this page</a>.");
									break;
								case "SU":
                  fmWarningArray.push("The subheading <b>" + subHeadingArray[k] + "</b> is automatically exploded in PubMed. In PubMed, this search will return more results because it will also search for the MeSH term <b>" +  fmMesh.toString().replace('exp ','').replace("GRRRAND","and").replace("ARRGHOR","or").replace("SERENOTY","not") + "</b> with the subheading <b>TR.</b> For more information see <a href='https://www.nlm.nih.gov/mesh/subhierarchy.html' target='_blank'>this page</a>.");
									break;
								case "TH":
                  fmWarningArray.push("The subheading <b>" + subHeadingArray[k] + "</b> is automatically exploded in PubMed. In PubMed, this search will return more results because it will also search for the MeSH term <b>" +  fmMesh.toString().replace('exp ','').replace("GRRRAND","and").replace("ARRGHOR","or").replace("SERENOTY","not") + "</b> with the subheadings <b>DH, DT, NU, PC, RT, RH, SU, and TR.</b> For more information see <a href='https://www.nlm.nih.gov/mesh/subhierarchy.html' target='_blank'>this page</a>.");
									break;
							}
						}
					}
				} // end subHeadingExplode for loop

				subHeadingArray2 = subHeadingArray.concat(tempArray);
			} // end subHeadingList for loop

		// go through each subheading in array (second time)
		for (k=0; k < subHeadingArray2.length; k++) {

			// convert user input subheading abbreviations into full phrases
				for (j = 0; j < subHeadingList.length; j++) {
					if (subHeadingArray2[k] == subHeadingCode[j]) {
						subHeadingArray2[k] = subHeadingArray2[k].replace(subHeadingArray2[k],subHeadingList[j]);
					}
					else {
						// do nothing
					}
				} // end subHeadingList for loop

			// format each subheading back into full mesh string
			subHeadingArray2[k] = fmMesh[0] + "/" + subHeadingArray2[k] + fmMeshType;
			subHeadingArray2[k] = addQuotes(subHeadingArray2[k]); // add quotes

		} // end subHeadingArray for loop

			// separate each string by OR
			fmString = subHeadingArray2.join(" OR ");

			fmString = fmBeg[0] + fmString + fmEnd[0]; // add any beginning parenthasis to string

			// add additional parenthesis if there are multiple subheadings
			if (fmString.search("OR") > 0) {
				fmString = "(" + fmString + ")";
			}

		} // end subheading processing

		else { // if no subheading
			fmString = fmBeg[0] + fmMesh[0] + fmMeshType + fmEnd[0]; // put all components back together
			fmString = addQuotes(fmString); // add quotes
		} // end no subheading processing

	} // end regular mesh processing

	fmString = fmString.replace(/\*/g,"");  // remove focus
	fmString = fmString.replace(/exp /ig,""); // remove explode

 	// warning array into single string
 	var fmWarning = fmWarningArray.join("|");

	fmOutputArray[0] = fmString;
    fmOutputArray[1] = fmWarning;
    return fmOutputArray;

} // function end

// ****************************************** KEYWORDS ******************************************
function formatKeyword(kwString, uPref) {

	kwTemp = kwString;

    //make an array to hold any warnings
    var kwWarningArray = [];

    //make an array to hold the outputs (string and warnings)
    var kwOutputArray = [];

	// to hold array of field codes
	var kwFieldArray = [];


	// for floating/exploded subheadings
	var subHeadingList = ["Abnormalities", "Administration and Dosage", "Adverse Effects", "Agonists", "Analogs and Derivatives", "Analysis", "Anatomy and Histology", "Antagonists and Inhibitors", "Biosynthesis", "Blood Supply", "Blood", "Cerebrospinal Fluid", "Chemical Synthesis", "Chemically Induced", "Chemistry", "Classification", "Complications", "Congenital", "Contraindications", "Cytology", "Deficiency", "Diagnosis", "Diagnostic Use", "Diet Therapy", "Diagnostic Imaging", "Drug Effects", "Drug Therapy", "Economics", "Education", "Embryology", "Enzymology", "Epidemiology", "Ethics", "Ethnology", "Etiology", "Genetics", "Growth and Development", "History", "Immunology", "Injuries", "Innervation", "Instrumentation", "Isolation and Purification", "Legislation and Jurisprudence", "Manpower", "Metabolism", "Methods", "Microbiology", "Mortality", "Nursing", "Organization and Administration", "Parasitology", "Pathogenicity", "Pathology", "Pharmacokinetics", "Pharmacology", "Physiology", "Physiopathology", "Poisoning", "Prevention and Control", "Psychology", "Radiation Effects", "Radiotherapy", "Rehabilitation", "Secondary", "Secretion", "Standards", "Statistics and Numerical Data", "Supply and Distribution", "Surgery", "Therapeutic Use", "Therapy", "Toxicity", "Transmission", "Transplantation", "Trends", "Ultrastructure", "Urine", "Utilization", "Veterinary", "Virology"];
	var subHeadingCode = ["AB", "AD", "AE", "AG", "AA", "AN", "AH", "AI", "BI", "BS", "BL", "CF", "CS", "CI", "CH", "CL", "CO", "CN", "CT", "CY", "DF", "DI","DU", "DH", "DG", "DE", "DT", "EC", "ED", "EM", "EN", "EP", "ES", "EH", "ET", "GE", "GD", "HI", "IM", "IN", "IR", "IS", "IP", "LJ", "MA", "ME", "MT", "MI", "MO", "NU", "OG", "PS", "PY", "PA", "PK", "PD", "PH", "PP", "PO", "PC", "PX", "RE", "RT", "RH", "SC", "SE", "ST", "SN", "SD", "SU", "TU", "TH", "TO", "TM", "TR", "TD", "UL", "UR", "UT", "VE", "VI"];

	// variable to hold any beginning parenthesis
	var kwBeg = new RegExp(/^[\n\r (]*/);
		kwBeg = kwBeg.exec(kwString);

	// variable to hold any end parenthesis
	var kwEnd = new RegExp(/[ )\r\n]*$/);
		kwEnd = kwEnd.exec(kwString);

	// variable to hold any nested parenthesis
		var kwNestedEnd = new RegExp(/[) ]*(?=\.)/);
		kwNestedEnd = kwNestedEnd.exec(kwString);

 	var kwNested = false;

 	if (kwString.search(/\)\s*\./) >= 0) { // if nested parenthesis
	 	kwNested = true;
	}
	else {
		kwNested = false;
	}

    kwString = kwString.replace(/[()]*/g,""); // remove any parenthesis (stored in kwEnd,kwBeg)
    var kwArray = kwString.split("."); // split into kw and field codes
    kwArray[1] = kwArray[1].replace(/\s/g,""); // remove any spaces from field codes

  if (kwArray[1].search(/ti,ab,kw/i) >= 0) { // ti,ab,kw --> tiabkw
    kwArray[1] = kwArray[1].replace(/ti,ab,kw/,"tiabkw");
    }

	if (kwArray[1].search(/ti,ab/i) >= 0) { // ti,ab --> tiab
		kwArray[1] = kwArray[1].replace(/ti,ab/,"tiab");
	}

	if (kwArray[1].search(/[a-zA-Z]/) >= 0) { // if there are any field codes
		kwFieldArray = kwArray[1].split(","); // field codes into array
	}

    var b;

    // loop through field codes applied to kw
    for (b = 0; b < kwFieldArray.length; b++) {
    	// convert field codes
    if (kwFieldArray[b].search(/tiabkw/i) >= 0){ // title and abstract
  			kwFieldArray[b] = kwFieldArray[b].replace(/tiabkw/i,"[tiab]");
      kwWarningArray.push("In PubMed, [tiab] searches for title, collection title, abstract, other abstract, and author-supplied keywords. Therefore, the 'kw' field tag has been removed as it is redundant.");
    }
		else if (kwFieldArray[b].search(/tiab/i) >= 0){ // title and abstract
			kwFieldArray[b] = kwFieldArray[b].replace(/tiab/i,"[tiab]");
      kwWarningArray.push("In Ovid, the .ti,ab command searches both title and abstract. However, in PubMed, [tiab] searches for title, collection title, abstract, other abstract, and author-supplied keywords. Therefore, this pubmed search may return more results than the original ovid one.");
		}
		else if (kwFieldArray[b].search(/tw/i) >= 0){ // text word
			kwFieldArray[b] = kwFieldArray[b].replace(/tw/i,"[tiab]");
      kwWarningArray.push("In Ovid, the .tw or .ti,ab command searches both title and abstract. However, in PubMed, [tiab] searches for title, collection title, abstract, other abstract, and author-supplied keywords. Therefore, this pubmed search may return more results than the original ovid one. Please note also that while both Ovid MEDLINE and PubMed have a textword (tw) search, they search different fields in each database.");
		}
		else if (kwFieldArray[b].search(/mp/i) >= 0){ // multipurpose
			if (uPref == 0){
				kwFieldArray[b] = kwFieldArray[b].replace(/mp/i,"[tiab]");
				kwWarningArray.push("The multipurpose (mp) field tag searches the following fields in ovid: abstract (ab), keyword heading word (kf), name of substance word (nm), original title (ot), protocol supplementary concept word (px), rare disease supplementary concept word (rx), subject heading word (hw), synonyms (sy), title (ti), unique identifier (ui). Many of these field codes cannot be searched in PubMed. Search has been translated as [tiab] OR [nm] OR [mh] OR [tt] OR [pmid]. For an inexact, but simpler translation  to [tw], choose the Efficiency option.");
				kwFieldArray.push("nm","mh","ot","ui");
			}
			else{
				kwFieldArray[b] = kwFieldArray[b].replace(/mp/i,"[tw]");
				kwWarningArray.push("The multipurpose (mp) field tag searches the following fields in ovid: abstract (ab), keyword heading word (kf), name of substance word (nm), original title (ot), protocol supplementary concept word (px), rare disease supplementary concept word (rx), subject heading word (hw), synonyms (sy), title (ti), unique identifier (ui). For simplicity, this search has been translated as [tw]. For a more exact translation, choose the Accuracy option.");
			}
		}
    // field codes are listed alphabetically after this point
		else if (kwFieldArray[b].search(/ab/i) >= 0){ // abstract
			kwFieldArray[b] = kwFieldArray[b].replace(/ab/i,"[tiab]");
			kwWarningArray.push("PubMed does not support abstract-only searches. <b>.ab</b> has been replaced with <b>[tiab]</b>, which may retrieve more results.");
		}
    // .ai —> [auid]
    else if (kwFieldArray[b].search(/ai/i) >= 0){ // Author Name ID
      kwFieldArray[b] = kwFieldArray[b].replace(/ai/i,"[auid]");
    }
    else if (kwFieldArray[b].search(/af/i) >= 0){ // all fields
      kwFieldArray[b] = kwFieldArray[b].replace(/af/i,"[all]");
    }
    else if (kwFieldArray[b].search(/ax/i) >= 0){ // Author Last Name
      kwFieldArray[b] = kwFieldArray[b].replace(/ax/i,"[au]");
    }
    else if (kwFieldArray[b].search(/ci/i) >= 0){ // Conflict of Interest
      kwFieldArray[b] = kwFieldArray[b].replace(/ci/i,"[coi]");
    }
    else if (kwFieldArray[b].search(/cp/i) >= 0){ // country of publication
      kwFieldArray[b] = kwFieldArray[b].replace(/cp/i,"[pl]");
    }
		else if (kwFieldArray[b].search(/dz/i) >= 0 && kwArray[0].search(/docz/i) >= 0){ // docz.dz
      kwFieldArray[b] = kwFieldArray[b].replace(/dz/i,"[sb]");
			kwArray[0] = "all";
		}
		else if (kwFieldArray[b].search(/pt/i) >= 0){ // publication type
			if (uPref == 0){
			kwFieldArray[b] = kwFieldArray[b].replace(/pt/i,"[pt:noexp]");
			kwWarningArray.push("The publication type (pt) field tag does not automatically explode in Ovid, and so this translation duplicates that in PubMed. For an inexact, but simpler translation  to [pt], choose the Efficiency option.");
		}
		else {
			kwFieldArray[b] = kwFieldArray[b].replace(/pt/i,"[pt]");
			kwWarningArray.push("The publication type (pt) field tag does not automatically explode in Ovid, and automatically explodes in PubMed. To search this term without exploding in PubMed, choose the Accuracy option.");
		}
		}
    else if (kwFieldArray[b].search(/da/i) >= 0){ // Date, Mesh
      kwFieldArray[b] = kwFieldArray[b].replace(/da/i,"[mhda]");
    }
    else if (kwFieldArray[b].search(/do/i) >= 0){ // DOI/Location ID/Publisher Item Identifier
      kwFieldArray[b] = kwFieldArray[b].replace(/do/i,"[lid]");
    }
    else if (kwFieldArray[b].search(/di/i) >= 0){ // DOI/Location ID/Publisher Item Identifier
      kwFieldArray[b] = kwFieldArray[b].replace(/di/i,"[lid]");
    }
    else if (kwFieldArray[b].search(/dt/i) >= 0){ // Date, Create
      kwFieldArray[b] = kwFieldArray[b].replace(/dt/i,"[crdt]");
    }
    else if (kwFieldArray[b].search(/ed/i) >= 0){ // Date, Completion/Entry
      kwFieldArray[b] = kwFieldArray[b].replace(/ed/i,"[dcom]");
    }
    else if (kwFieldArray[b].search(/ee/i) >= 0){ // Editor
      kwFieldArray[b] = kwFieldArray[b].replace(/ee/i,"[ed]");
    }
    else if (kwFieldArray[b].search(/ep/i) >= 0){ // Date of Publication, Electronic
      kwFieldArray[b] = kwFieldArray[b].replace(/ep/i,"[dep]");
    }
    else if (kwFieldArray[b].search(/es/i) >= 0){ // ISSN Electronic
      kwFieldArray[b] = kwFieldArray[b].replace(/es/i,"[ta]");
    }
    else if (kwFieldArray[b].search(/ez/i) >= 0){ // Date, Entrez
      kwFieldArray[b] = kwFieldArray[b].replace(/ez/i,"[edat]");
    }
    else if (kwFieldArray[b].search(/fa/i) >= 0){ // full author name
      kwFieldArray[b] = kwFieldArray[b].replace(/fa/i,"[fau]");
    }
		else if (kwFieldArray[b].search(/fs/i) >=0){ // floating subheading
      kwFieldArray[b] = kwFieldArray[b].replace(/fs/i,"[sh:noexp]");
    }
		else if (kwFieldArray[b].search(/xs/i) >=0){ // exploded subheading
			kwFieldArray[b] = kwFieldArray[b].replace(/xs/i,"[sh]");
		}
    else if (kwFieldArray[b].search(/gr|gc|gi|no|go/i) >= 0){ // Grant Information
      kwFieldArray[b] = kwFieldArray[b].replace(/gr|gc|gi|no|go/i,"[gr]");
    }
    else if (kwFieldArray[b].search(/hw/i) >= 0){ // heading word (no translation)
      kwFieldArray[b] = kwFieldArray[b].replace(/hw/i,"[mh]");
      kwWarningArray.push("PubMed does not support heading word (.hw) searches. The closest equivalent is mesh heading [mh], which may retrieve fewer results.");
    }
    else if (kwFieldArray[b].search(/ib/i) >= 0){ // ISBN
      kwFieldArray[b] = kwFieldArray[b].replace(/ib/i,"[is]");
    }
    else if (kwFieldArray[b].search(/id/i) >= 0){ // Article Identifier
      kwFieldArray[b] = kwFieldArray[b].replace(/id/i,"[aid]");
    }
    else if (kwFieldArray[b].search(/il/i) >= 0){ // ISSN Linking
      kwFieldArray[b] = kwFieldArray[b].replace(/il/i,"[ta]");
    }
    else if (kwFieldArray[b].search(/in/i) >= 0){ // institution
      kwFieldArray[b] = kwFieldArray[b].replace(/in/i,"[ad]");
    }
    else if (kwFieldArray[b].search(/io/i) >= 0){ // Journal ISO/Title Abbreviation
      kwFieldArray[b] = kwFieldArray[b].replace(/io/i,"[ta]");
    }
    else if (kwFieldArray[b].search(/is/i) >= 0){ // ISSN Print
      kwFieldArray[b] = kwFieldArray[b].replace(/is/i,"[ta]");
    }
    else if (kwFieldArray[b].search(/ja/i) >= 0){ // journal title abbreviated
      kwFieldArray[b] = kwFieldArray[b].replace(/ja/i,"[ta]");
    }
    else if (kwFieldArray[b].search(/jc/i) >= 0){ // NLM Journal Code
      kwFieldArray[b] = kwFieldArray[b].replace(/jc/i,"[jid]");
    }
    else if (kwFieldArray[b].search(/jn/i) >= 0){ // journal title
      kwFieldArray[b] = kwFieldArray[b].replace(/jn/i,"[journal]");
    }
    // lancet.jw —> warning message that there is no equivalent. Change to [journal].
    else if (kwFieldArray[b].search(/jw/i) >= 0){ // journal word
      kwFieldArray[b] = kwFieldArray[b].replace(/jw/i,"[journal]");
      kwWarningArray.push("PubMed does not support journal word (.jw) searches. The closest equivalent is [journal], which may retrieve fewer results.");
    }
    else if (kwFieldArray[b].search(/kf/i) >= 0){ // keyword heading word (no translation)
      kwFieldArray[b] = kwFieldArray[b].replace(/kf/i,"[ot]");
      kwWarningArray.push("PubMed does not support keyword heading word (.kf) searches. The closest equivalent is other term [ot], which may retrieve fewer results.");
    }
    else if (kwFieldArray[b].search(/kw/i) >= 0){ // keyword (other term)
      kwFieldArray[b] = kwFieldArray[b].replace(/kw/i,"[ot]");
    }
    else if (kwFieldArray[b].search(/lg/i) >= 0){ // language
      kwFieldArray[b] = kwFieldArray[b].replace(/lg/i,"[la]");
    }
    else if (kwFieldArray[b].search(/nj/i) >= 0){ // NLM Journal Name
      kwFieldArray[b] = kwFieldArray[b].replace(/nj/i,"[journal]");
    }
    else if (kwFieldArray[b].search(/nm/i) >= 0){ // name of substance word
      kwFieldArray[b] = kwFieldArray[b].replace(/nm/i,"[nm]");
    }
    else if (kwFieldArray[b].search(/nw/i) >= 0){ // NLM Journal Word<
      kwFieldArray[b] = kwFieldArray[b].replace(/nw/i,"[journal]");
      kwWarningArray.push("PubMed does not support NLM journal word (.nw) searches. The closest equivalent is [journal], which may retrieve fewer results.");
    }
    // .oa —> warning that there is no equivalent. "This is one of the many fields searched by the [tiab] and [tw] searches in PubMed, but it cannot be searched separately.” Change to [tiab].
    else if (kwFieldArray[b].search(/oa/i) >= 0){ // original title (transliterated title)
      kwFieldArray[b] = kwFieldArray[b].replace(/oa/i,"[tiab]");
      kwWarningArray.push("PubMed does not support Other Abstract (.oa) field tag searching. This is one of the many fields searched by the [tiab] and [tw] searches in PubMed, but it cannot be searched separately. Field has been changed to [tiab]");
    }
		else if (kwFieldArray[b].search(/ot/i) >= 0){ // original title (transliterated title)
			kwFieldArray[b] = kwFieldArray[b].replace(/ot/i,"[tt]");
		}
    else if (kwFieldArray[b].search(/pa/i) >= 0){ // first author name
      kwFieldArray[b] = kwFieldArray[b].replace(/pa/i,"[1au]");
    }
    else if (kwFieldArray[b].search(/pb/i) >= 0){ // Publisher
      kwFieldArray[b] = kwFieldArray[b].replace(/pb/i,"[pubn]");
    }
    else if (kwFieldArray[b].search(/pn/i) >= 0){ // peronal name as subject
      kwFieldArray[b] = kwFieldArray[b].replace(/pn/i,"[ps]");
    }
    else if (kwFieldArray[b].search(/ps/i) >= 0){ // Protocol Supplementary Concept
      kwFieldArray[b] = kwFieldArray[b].replace(/ps/i,"[supplementary concept]");
    }
    else if (kwFieldArray[b].search(/px/i) >= 0){ // Protocol Supplementary Concept Word
      kwFieldArray[b] = kwFieldArray[b].replace(/px/i,"[supplementary concept]");
      kwWarningArray.push("PubMed only supports .px searches that are one word long (no phrases).");
    }
    else if (kwFieldArray[b].search(/rd/i) >= 0){ // Date, Modification/Revision
      kwFieldArray[b] = kwFieldArray[b].replace(/rd/i,"[lr]");
    }
    else if (kwFieldArray[b].search(/rs/i) >= 0){ // Rare Disease Supplementary Concept
      kwFieldArray[b] = kwFieldArray[b].replace(/rs/i,"[supplementary concept]");
    }
    else if (kwFieldArray[b].search(/rx/i) >= 0){ // Rare Disease Supplementary Concept Word
      kwFieldArray[b] = kwFieldArray[b].replace(/rx/i,"[supplementary concept]");
      kwWarningArray.push("PubMed only supports .rx searches that are one word long (no phrases).");
    }
		else if (kwFieldArray[b].search(/sb/i) >= 0){ // subsets
			if (kwArray[0].search(/aids hiv journals/i) >= 0) {
				kwArray[0] = kwArray[0].replace(/aids hiv journals/i,"aids");
			}
			else if (kwArray[0].search(/bioethicsjournals/i) >= 0) {
				kwArray[0] = kwArray[0].replace(/bioethicsjournals/i,"bioethics");
			}
			else if (kwArray[0].search(/history of medicine journals/i) >= 0) {
				kwArray[0] = kwArray[0].replace(/history of medicine journals/i,"history");
			}
			else if (kwArray[0].search(/national aeronautics GRRRAND space  administration nasa journals/i) >= 0) {
				kwArray[0] = kwArray[0].replace(/national aeronautics GRRRAND space  administration nasa journals/i,"space");
			}
			else if (kwArray[0].search(/om/i) >= 0) {
				kwArray[0] = kwArray[0].replace(/om/i,"oldmedline");
			}
			else if (kwArray[0].search(/[a-zA-Z]{1,3}/i) >= 0) { // match between 1 and 3 alpha characters
				kwArray[0] = kwArray[0].replace(/[a-zA-Z]{1,3}/i,"jsubset$&");
				kwFieldArray[b] = kwFieldArray[b].replace(/sb/i,"[text]");
			}
			else {
				// do nothing
			}
		}
    else if (kwFieldArray[b].search(/sh/i) >= 0){ // mesh heading unexploded
      kwFieldArray[b] = kwFieldArray[b].replace(/sh/i,"[mesh:noexp]");
    }
    else if (kwFieldArray[b].search(/st/i) >= 0){ // Status
			kwFieldArray[b] = kwFieldArray[b].replace(/st/i,"[sb]");
			if (kwArray[0].search(/in process/i) >= 0) {
				kwArray[0] = kwArray[0].replace(/in process/i,"inprocess");
			}
			else if (kwArray[0].search(/oldmedline citations/i) >= 0) {
				kwArray[0] = kwArray[0].replace(/oldmedline citations/i,"oldmedline");
			}
			else if (kwArray[0].search(/pubmed SERENOTY medline/i) >= 0) {
				kwArray[0] = kwArray[0].replace(/pubmed SERENOTY medline/i,"pubmednotmedline");
			}
			else if (kwArray[0].search(/in data review/i) >= 0) {
				kwArray[0] = kwArray[0].replace(/in data review/i,"indatareview");
			}
			else {
				// do nothing
			}
    }
    else if (kwFieldArray[b].search(/ui/i) >= 0){ // unique identifier
      kwFieldArray[b] = kwFieldArray[b].replace(/ui/i,"[pmid]");
    }
    else if (kwFieldArray[b].search(/vo/i) >= 0){ // volume
      kwFieldArray[b] = kwFieldArray[b].replace(/vo/i,"[vi]");
    }
    else if (kwFieldArray[b].search(/xm/i) >= 0){ // mesh heading exploded
      kwFieldArray[b] = kwFieldArray[b].replace(/xm/i,"[mh]");
    }
    else if (kwFieldArray[b].search(/yr/i) >= 0){ // year
      kwFieldArray[b] = kwFieldArray[b].replace(/yr/i,"[dp]");
    }
    // else replace .xx with [xx]
		else {
      kwFieldArray[b] = "[" + kwFieldArray[b] + "]";
		}

		// truncation and wildcards and numbers
		if (kwArray[0].search(/\*/g) >= 0) { // truncation * is used (end of kw)
			// don't add quotes
			// remove any existing quotes
			kwArray[0] = kwArray[0].replace(/\"/g,"");
		}
		else if (kwArray[0].search(/\$/g) >= 0) { // truncation $ is used (end of kw)
			kwArray[0] = kwArray[0].replace(/\$/,"*"); // convert $ --> *
			// don't add quotes
			// remove any existing quotes
			kwArray[0] = kwArray[0].replace(/\"/g,"");
		}
    else if (kwArray[0].search(/\:/g) >= 0) { // truncation : is used (end of kw)
      kwArray[0] = kwArray[0].replace(/\:/,"*"); // convert : --> *
      // don't add quotes
      // remove any existing quotes
      kwArray[0] = kwArray[0].replace(/\"/g,"");
    }
		else if (kwArray[0].search(/[A-Za-z][\?\#][A-Za-z]/) >= 0) { // wildcard ? or # is used
			kwWarningArray.push("PubMed does not support wildcards. For the most accurate translation, write out all possible word combinations.");
		}
		// if it's a number
		else if (kwFieldArray[b].search("number") >= 0) {
			kwFieldArray[b] = kwFieldArray[b].replace("[number]","");
			kwArray[0] = "#" + kwArray[0];
		}

		// if it's a floating/exploded subheading
		else if (kwFieldArray[b].search(/sh/i) >= 0) {
			kwArray[0] = kwArray[0].toUpperCase();
			// replace two letter code with full subheading
			for (c=0; c < subHeadingCode.length; c++) {
				if (kwArray[0] == subHeadingCode[c]) {
					kwArray[0] = subHeadingList[c];
				}
			}
		kwArray[0] = addQuotes(kwArray[0]);
		}

		// normal keyword; add quotations
		else {
			kwArray[0] = addQuotes(kwArray[0]);
		}

		// format back into full keyword strings
		kwFieldArray[b] = kwArray[0] + kwFieldArray[b];

		// keyword strings into one string
		kwString = kwFieldArray.join(" OR ");

		if (kwString.search("OR") > 0) { // add parenthesis around kw with multiple field codes separated by OR
			kwString = "(" + kwString + ")";
		}
	} // end for loop

	if (kwNested == true) { // if nested parenthesis
		kwString = kwBeg + kwString + kwNestedEnd + kwEnd;
	}
	else { // if non-nested parenthesis
		kwString = kwBeg + kwString + kwEnd;
	}

	// kwString = kwTemp;

	// warnings into single string
	var kwWarningString = kwWarningArray.join("|");

	kwOutputArray[0] = kwString;
    kwOutputArray[1] = kwWarningString;
    return kwOutputArray;

} // function end

// ****************************************** ADD QUOTES ******************************************
function addQuotes(aqString) {

	if (aqString.search(/\"/) >= 0) { // if string already has quotes
		aqString = aqString.replace(/\"/g,"");
		aqString = aqString.replace(/[\(\)a-zA-Z\d \/,*-]+/,"\"$&\"");
	}

	else {
		aqString = aqString.replace(/[\(\)a-zA-Z\d \/,*-]+/,"\"$&\""); // add quotes
	}
	return aqString;

} // function end

// ****************************************** FORMAT OTP LIMITS ******************************************

function formatLimitOTP(flString) {

	var flWarningString = "";
	var flOutputArray = [];

	flString = flString.replace(/limit (\d+) to /i,"#$1 AND ");

// journal subsets
	flString = flString.replace(/"*history of medicine journals non index medicus"*/ig,"jsubsetqis").replace(/"*core clinical journals \(aim\)"*/ig,"jsubsetaim").replace(/bioethics journals/ig,"jsubsete").replace(/biotechnology journals/ig,"jsubsetb").replace(/communication disorders journals/ig,"jsubsetc").replace(/consumer health journals/ig,"jsubsetk").replace(/dentistry journals/ig,"jsubsetd").replace(/foreign journals/ig,"jsubsetf").replace(/health administration journals/ig,"jsubseth").replace(/health technology assessment journals/ig,"jsubsett").replace(/"*history of medicine journals"*/ig,"jsubsetq").replace(/index medicus/ig,"jsubsetim").replace(/"*national aeronautics GRRRAND space administration \(nasa\) journals"*/ig,"jsubsets").replace(/nursing journals/ig,"jsubsetn").replace(/population information citations/ig,"jsubsetj").replace(/reproduction journals/ig,"jsubsetr").replace(/aids\/hiv journals/ig,"jsubsetx");

// subject subsets
	flString = flString.replace(/aids/ig,"aids[sb]").replace(/bioethics/ig,"bioethics[sb]").replace(/cancer/ig,"cancer[sb]").replace(/Complementary Medicine/gi,"cam[sb]").replace(/Dietary Supplements/gi,"dietsuppl[sb]").replace(/History of Medicine/gi,"history[sb]").replace(/Space Life Sciences/ig,"space[sb]").replace(/Systematic Reviews/gi,"systematic[sb]").replace(/Toxicology/gi,"tox[sb]").replace(/Veterinary Science/ig,"veterinary[sb]").replace(/communication disorders journals/ig,"jsubsetc[text]");

// text availability
	flString = flString.replace(/structured abstracts/ig,"hasstructuredabstract").replace(/abstracts/ig,"hasabstract").replace(/(ovid full text available|full text)/gi,"your-institution-code[sb]");

// age groups
	flString = flString.replace(/\"aged \(80 GRRRAND over\)\"/i,"\"aged, 80 and over\"[mesh]").replace(/\"all aged \(65 GRRRAND over\)\"/i,"\"aged\"[mesh]").replace(/\"middle aged \(45 plus years\)\"/i, "\(\"middle aged\"[mesh] OR \"aged\"[mesh]\)").replace(/\"middle age \(45 to 64 years\)\"/i,"\"middle aged\"[mesh]").replace(/(\"young adult GRRRAND adult \(19-24 GRRRAND 19-44\)\"|\"adult \(19 to 44 years\)\")/ig,"\"adult\"[mesh:noexp]").replace(/\"young adult \(19 to 24 years\)\"/i, "\"young adult\"[mesh]").replace(/\"adolescent \(13 to 18 years\)\"/i,"\"adolescent\"[mesh]").replace(/\"child \(6 to 12 years\)\"/i,"\"child\"[mesh:noexp]").replace(/\"preschool child \(2 to 5 years\)\"/i,"\"child, preschool\"[mesh]").replace(/\"infant \(1 to 23 months\)\"/i,"\"infant\"[mesh:noexp]").replace(/\"newborn infant \(birth to 1 month\)\"/i, "\"infant, newborn\"[mesh]").replace(/\"all adult \(19 plus years\)\"/i, "\"adult\"[mesh]").replace(/\"all child \(0 to 18 years\)\"/i, "\(\"infant\"[mesh] OR \"child\"[mesh] OR \"adolescent\"[mesh]\)").replace(/\"all infant \(birth to 23 months\)\"/i, "\"infant\"[mesh]");

// check tags
	flString = flString.replace(/(humans|male|female)/ig,"\"$1\"[mesh]").replace(/(pregnancy|animals)/ig,"\"$1\"[mesh:noexp]");

// species
	flString = flString.replace(/(cats|cattle|chick embryo|dogs|goats|guinea pigs|horses|mice|rabbits|rats|sheep|swine)/ig,"\"$1\"[mesh]").replace(/hamsters/i,"\"cricetinae\"[mesh]");

// status
	flString = flString.replace(/"*in data review"*/ig,"indatareview[sb]").replace(/"*in process"*/ig,"inprocess[sb]").replace(/"*pubmed SERENOTY medline"*/ig,"pubmednotmedline[sb]").replace(/medline(?!\[sb\])/ig,"medline[sb]").replace(/"*publisher"*/,"publisher[sb]");

// publication type
	flString = flString.replace(/"*(addresses|autobiography|bibliography|biography|case reports|classical article|clinical conference|clinical study|clinical trial, all|clinical trial, phase iii|clinical trial, phase ii|clinical trial, phase iv|clinical trial, phase i|clinical trial|comment|comparative study|congresses|consensus development conference, nih|consensus development conference|controlled clinical trial|corrected GRRRAND republished article|dataset|dictionary|directory|duplicate publication|editorial|english abstract|evaluation studies|festschrift|government publications|guideline|historical article|interactive tutorial|interview|introductory journal article|journal article|lectures|legal cases|legislation|letter|meta analysis|multicenter study|newspaper article|news|observational study|overall|patient education handout|periodical index|personal narratives|portraits|practice guideline|pragmatic clinical trial|published erratum|randomized controlled trial|research support, american recovery GRRRAND reinvestment act|research support, nih, extramural|research support, nih, intramural|research support, non us gov't|research support, us gov't, non phs|research support, us gov't, phs|retracted publication|retraction of publication|(scientific integrity )*review( articles)*(?!s|\[)|technical report|twin study|validation studies|video-audio media|webcasts)"*/ig,"\"$1\"[pt:noexp]").replace(/review articles/ig,"review");

// language
	flString = flString.replace(/(afrikaans|albanian|arabic|armenian|azerbaijani|belorussian|bengali|bosnian|bulgarian|burmese|catalan|chinese|croatian|czech|danish|dutch|english( language)*(?! abstract)|esperanto|estonian|finnish|flemish|french|gaelic, scots|georgian|german|greek|hausa|hebrew|hindi|hungarian|icelandic|indonesian|interlingua|italian|japanese|kirghiz|korean|latin|latvian|lithuanian|macedonian|malay|marathi|masai|multilingual|norwegian|persian|polish|portuguese|pushto|rumanian|russian|serbian|slovak|slovene|spanish|swahili|swedish|tagalog|tamil|telugu|thai|turkish|ukrainian|urdu|vietnamese|welsh)/ig,"\"$1\"[lang]").replace(/english language/ig,"english");

//  clinical queries that are already in PubMed
	if (flString.search(/(causation-etiology|therapy|diagnosis|prognosis|clinical prediction guides) \(maximizes (sensitivity|specificity)\)/ig) >= 0) {
		flString = flString.replace(/"*([a-zA-Z-]+|clinical prediction guides) \(maximizes sensitivity\)"*/ig,"$1\/broad[filter]").replace(/"*([a-zA-Z-]+|clinical prediction guides) \(maximizes specificity\)"*/ig,"$1\/narrow[filter]").replace(/causation-etiology/ig,"etiology");
	}

// clinical queries that are in Ovid but not PubMed
// "best balance of" queries
// strategies from https://hiru.mcmaster.ca/hiru/HIRU_Hedges_MEDLINE_Strategies.aspx
if (flString.search(/best balance of/ig) >= 0) {
	flString = flString.replace(/\"reviews \(best balance of sensitivity GRRRAND specificity\)\"/ig,"\(meta analysis[ptyp] OR meta analysis[tiab] OR meta analysis[mesh] OR review[ptyp] OR search\*[tiab]\)").replace(/\"therapy \(best balance of sensitivity GRRRAND specificity\)\"/ig,"\(randomized controlled trial[ptyp] OR randomized[tiab] OR placebo[tiab]\)").replace(/\"diagnosis \(best balance of sensitivity GRRRAND specificity\)\"/ig,"\(sensitive\*[tiab] OR sensitivity and specificity[mesh] OR \(predictive[tiab] AND value\*[tiab]\) OR predictive value of tests[mesh] OR accuracy\*[tiab]\)").replace(/\"prognosis \(best balance of sensitivity GRRRAND specificity\)\"/ig,"\(prognosis[mesh:noexp] OR diagnosed[tiab] OR cohort\*[tiab] OR cohort effect[mesh] OR cohort studies[mesh:noexp] OR predictor\*[tiab] OR death[tiab] OR \"models, statistical\"[mesh]\)").replace(/\"causation-etiology \(best balance of sensitivity GRRRAND specificity\)\"/ig,"\(risk[tiab] OR risk[mesh:noexp] OR mortality[tiab] OR mortality[mesh:noexp] OR cohort[tiab]\)").replace(/\"clinical prediction guides \(best balance of sensitivity GRRRAND specificity\)\"/ig,"\(predict\*[tiab] OR validat\*[tiab] OR develop[tiab]\)").replace(/\"costs \(best balance of sensitivity GRRRAND specificity\)\"/ig,"\(\"costs and cost analysis\"[mesh] OR costs[tiab] OR cost effective\*[tiab]\)").replace(/\"qualitative \(best balance of sensitivity GRRRAND specificity\)\"/ig,"\(interview\*[tiab] OR interviews[mesh:noexp] OR experience\*[tw] OR qualitative[tiab]\)").replace(/\"economics \(best balance of sensitivity GRRRAND specificity\)\"/ig,"\(cost\*[tiab] OR \"costs and cost analysis\"[mesh:noexp] OR cost benefit analys\*[tiab] OR cost-benefit analysis[mesh] OR health care costs[mesh:noexp]\)");
}

// clinical queries in ovid but not pubmed
// sensitivity/specificity queries
// strategies from https://hiru.mcmaster.ca/hiru/HIRU_Hedges_MEDLINE_Strategies.aspx
if (flString.search(/(reviews|costs|qualitative|economics) \(maximizes (sensitivity|specificity)\)/ig) >= 0) {
	flString = flString.replace(/\"reviews \(maximizes sensitivity\)\"/ig,"\(search\*[tiab] OR meta analysis[ptyp] OR meta analysis[tiab] OR meta analysis[mesh] OR review[ptyp] OR diagnosis[subheading] OR associated[tiab]\)").replace(/\"reviews \(maximizes specificity\)\"/ig,"\(MEDLINE[tiab] OR \(systematic[tiab] AND review[tiab]\) OR meta analysis[ptyp]\)").replace(/\"costs \(maximizes sensitivity\)\"/ig,"\(economics[subheading:noexp] OR cost[tiab] OR health care costs[mesh:noexp]\)").replace(/\"costs \(maximizes specificity\)\"/ig,"\(cost effectiveness[tiab] OR health care costs[mesh:noexp]\)").replace(/\"qualitative \(maximizes sensitivity\)\"/ig,"\(interview\*[tiab] OR psychology[subheading:noexp] OR health services administration[mesh]\)").replace(/\"qualitative \(maximizes specificity\)\"/ig,"\(qualitative[tiab] OR themes[tiab]\)").replace(/\"economics \(maximizes sensitivity\)\"/ig,"\(randomized controlled trial[ptyp] OR cost effectiveness[tiab] OR cost effective[tiab]\)").replace(/\"economics \(maximizes specificity\)\"/ig,"\(cost effective[tiab] OR sensitivity analys\*[tiab]\)");
}

// years ago published (e.g. "last 5 years")
	var d = new Date();
	d = d.getDate();

	var y = new Date();
	y = y.getFullYear();

	var m = new Date();
	m = m.getMonth();

	var inputDate = [];
	var yearStart = 0;
	var lastYear = 0;

// last x years
if (flString.search(/Last [\d]+ years/ig) >= 0) {
	inputDate = flString.match(/[\d]+/g);
	yearStart = parseInt(y) - parseInt(inputDate[1]);
	flString = flString.replace(/last [\d]+ years/ig,"\(\"" + yearStart + "\/" + m + "\/" + d + "\"[PDat] : \"" + y + "\/" + m + "\/" + d + "\"[PDat]\)");
}

// last year
if (flString.search(/last year/) >= 0){
	lastYear = parseInt(y) - 1;
	flString = flString.replace(/last year/,"\(\"" + lastYear + "\/" + m + "\/" + d + "\"[PDat] : \"" + y + "\/" + m + "\/" + d + "\"[PDat]\)");
}

// year published
	flString = flString.replace(/yr=\"([\d]{4})[ ]*-[ ]*([\d]{4}|current)\"/i," \(\"$1\"[PDAT] : \"$2\"[PDAT]\)").replace(/current/ig,y);
// date of completion/entry
	flString = flString.replace(/ed=\"([\d]{8})[ ]*-[ ]*([\d]{8})\"/i," \(\"$1\"[dcom] : \"$2\"[dcom]\)");
// date of modification/revision
	flString = flString.replace(/rd=\"([\d]{8})[ ]*-[ ]*([\d]{8})\"/i," \(\"$1\"[lr] : \"$2\"[lr]\)");

//replace any accidental double quotes with single quotes
	flString = flString.replace(/\"\"/ig,"\"")

	flOutputArray[0] = flString;
	flOutputArray[1] = flWarningString;
	return flOutputArray;

} // function end

//*********************************************PTO functions start***********************************************

function transposePTO(inputline, uPref) {


    //document.getElementById("output4").innerHTML ="yikes";
    //read in the user input (PubMed search strategy)
    //var inputline = document.getElementById("userEntry").value;
    //document.getElementById("output4").innerHTML = inputline;
    var outputline = "blank";

    //make an array for testing output
    var testingArray = ["test","test","test"];
    var testingIndex = 0;

    //make an array for warnings
    var warningArray = ["", ""];
    var warningIndex = 0;
    var wi = 0;
    var wiPlus = 1;
    var warningShortlist = ["",""];
    var wsli = 0;
    var warningShortlistItemNos = ["",""];
    var wslini = 0;

    //make an array to receive the output of other functions and split it into output and warnings
    var outputReceiver = [null, null];

    //this finds boolean operators in lowercase, and, if they are preceded or followed by the right syntax, changes them to uppercase
    inputline = inputline.replace(/\] or /g,"\] OR ");
    inputline = inputline.replace(/\] and /g,"\] AND ");
    inputline = inputline.replace(/\] not /g,"\] NOT ");
    inputline = inputline.replace(/ or \"/g," OR \"");
    inputline = inputline.replace(/ and \"/g," AND \"");
    inputline = inputline.replace(/ not \"/g," NOT \"");
    inputline = inputline.replace(/\) or /g,"\) OR ");
    inputline = inputline.replace(/\) and /g,"\) AND ");
    inputline = inputline.replace(/\) not /g,"\) NOT ");
    inputline = inputline.replace(/ or \(/g," OR \(");
    inputline = inputline.replace(/ and \(/g," AND \(");
    inputline = inputline.replace(/ not \(/g," NOT \(");

	//split by linebreaks
	var lineArray = inputline.split(/[\n\r]/);

		// go through each element in the array
		var h;
		for (h = 0; h < lineArray.length; h++) {

		//split the string by the word "Filter" to find any limits
    //var filterArray = lineArray[h].split(" Filters: ");
		lineArray[h] = lineArray[h].replace(/ Filters:/,"<br />");

    //split the string by any OR operators and put the pieces into an array
    var orArray = lineArray[h].split(" OR ");
    //document.getElementById("output1").innerHTML = orArray;
    var orLength = orArray.length;
    var i;

    //go through each element in the array
    for (i = 0; i < orLength; i++){

        //split the string by any AND operators and put the pieces into an array
        var andArray = orArray[i].split(" AND ");
        var andLength = andArray.length;
        var j;

        // go through each element in the array
        for (j = 0; j < andLength; j++){

            //split the string by any NOT operators and put the pieces into an array
            var notArray = andArray[j].split(" NOT ");
            var notLength = notArray.length;
            var k;

            // go through each element in the array
            for (k = 0; k < notLength; k++){

              //check for a space between end quote and tag, and remove
              notArray[k] = notArray[k].replace(/\" \[/,"\"\[");

              //remove the parentheses
              notArray[k] = notArray[k].replace(/^\(+/,'$&GRRARRGH');
              notArray[k] = notArray[k].replace(/\)+$/,"GRRARRGH$&");
              var parenArray = notArray[k].split("GRRARRGH");
              if (parenArray.length > 1){
                if (parenArray[0].search(/\(/) >=0){
                  notArray[k] = parenArray[1];
                }
                else{
                  notArray[k] = parenArray[0];
                }
              }

              //this checks for the attributes of the search term.

              //is the term is a MeSH term?
              if (notArray[k].search(/\[Me/i) >= 0 || notArray[k].search(/\[Ma/i) >= 0 || notArray[k].search(/\[MH\]/i) >= 0 || notArray[k].search(/\[MH\:Noexp\]/i) >= 0){
                    //testingArray[testingIndex] = "mesh";
                    outputReceiver = formatMeshPTO(notArray[k]);
                    notArray[k] = outputReceiver[0];
                    //warningArray[warningIndex] = warningArray[warningIndex] + outputReceiver[1];
                    warningArray[warningIndex] = outputReceiver[1];
              }

              //is the term a controlled non-MesH?

              //is the term a Pharmacologic Action?
              else if (notArray[k].search(/\[pa\]/i) >= 0 || notArray[k].search(/\[pharm/i) >= 0){
                    notArray[k] = notArray[k].replace(/\[p[\w| ]+\]/i,"[Mesh]");
                    outputReceiver = formatMeshPTO(notArray[k]);
                    notArray[k] = outputReceiver[0];
                    warningArray[warningIndex] = outputReceiver[1];
              }

              //is the term a publication type?
              else if (notArray[k].search(/\[pt/i) >= 0 || notArray[k].search(/\[publication/i) >= 0){
                    outputReceiver = formatControlledPTO(notArray[k]);
                    notArray[k] = outputReceiver[0];
                    warningArray[warningIndex] = outputReceiver[1];
              }

              //is the term a subheading?
              else if (notArray[k].search(/\[subheading/i) >= 0 || notArray[k].search(/\[sh/i) >= 0){
                    //testingArray[testingIndex] = "sh";
                    //outputReceiver = [notArray[k],"hooray"];
                    outputReceiver = formatControlledPTO(notArray[k]);
                    notArray[k] = outputReceiver[0];
                    //warningArray[warningIndex] = warningArray[warningIndex] + outputReceiver[1];
                    warningArray[warningIndex] = outputReceiver[1];
              }

              //is the term a supplementary concept?
              else if (notArray[k].search(/\[supplementary/i) >= 0 || notArray[k].search(/\[nm/i) >= 0){
                    outputReceiver = formatControlledPTO(notArray[k]);
                    notArray[k] = outputReceiver[0];
                    warningArray[warningIndex] = outputReceiver[1];
              }

              //is the term a personal name as subject?
              else if (notArray[k].search(/\[subject/i) >= 0 || notArray[k].search(/\[ps/i) >= 0){
                    outputReceiver = formatControlledPTO(notArray[k]);
                    notArray[k] = outputReceiver[0];
                    warningArray[warningIndex] = outputReceiver[1];
              }

              //is the term an affiliation or institution?
              else if (notArray[k].search(/\[Affiliation/i) >= 0 || notArray[k].search(/\[ad/i) >= 0){
                    outputReceiver = formatControlledPTO(notArray[k]);
                    notArray[k] = outputReceiver[0];
                    warningArray[warningIndex] = outputReceiver[1];
              }

              //is the term an ID number?
              else if (notArray[k].search(/\[pmid/i) >= 0 || notArray[k].search(/\[uid/i) >= 0 || notArray[k].search(/\[auid/i) >= 0 || notArray[k].search(/\[jid/i) >= 0){
                    notArray[k] = formatIdNumbersPTO(notArray[k]);
                    warningArray[warningIndex] = "null";
              }
              else if (notArray[k].search(/\[gr/i) >= 0 || notArray[k].search(/\[si/i) >= 0 || notArray[k].search(/\[se/i) >= 0 || notArray[k].search(/\[is/i) >= 0){
                    notArray[k] = formatIdNumbersPTO(notArray[k]);
                    warningArray[warningIndex] = "null";
              }
              else if (notArray[k].search(/\[lid/i) >= 0 || notArray[k].search(/\[aid/i) >= 0 || notArray[k].search(/\[rn/i) >= 0 || notArray[k].search(/\[ec\/rn/i) >= 0){
                    notArray[k] = formatIdNumbersPTO(notArray[k]);
                    warningArray[warningIndex] = "null";
              }

              //is the term an author?
              else if (notArray[k].search(/\[Au/i) >= 0 || notArray[k].search(/\[cn/i) >=0 || notArray[k].search(/\[1au/i) >= 0 || notArray[k].search(/\[fau/i) >= 0 || notArray[k].search(/\[lastau/i) >= 0){
                    outputReceiver = formatAuthorPTO(notArray[k]);
                    notArray[k] = outputReceiver[0];
                    warningArray[warningIndex] = outputReceiver[1];
              }

              //is the term an investigator?
              else if (notArray[k].search(/\[ir/i) >= 0 || notArray[k].search(/\[investigator/i) >=0){
                    outputReceiver = formatAuthorPTO(notArray[k]);
                    notArray[k] = outputReceiver[0];
                    warningArray[warningIndex] = outputReceiver[1];
              }

              //is the term journal title or issn?
              else if (notArray[k].search(/\[jour/i) >= 0 || notArray[k].search(/\[ta/i) >= 0){
                    notArray[k] = formatJournalPTO(notArray[k]);
                    warningArray[warningIndex] = "null";
              }

              //is the term about the journal publisher?
              else if (notArray[k].search(/\[pl/i) >= 0 || notArray[k].search(/\[pubn/i) >= 0){
                    notArray[k] = formatJournalPTO(notArray[k]);
                    warningArray[warningIndex] = "null";
              }

              //is the term about the editor?
              else if (notArray[k].search(/\[ed\]/i) >= 0 || notArray[k].search(/\[editor/i) >= 0){
                    notArray[k] = formatJournalPTO(notArray[k]);
                    warningArray[warningIndex] = "null";
              }

              //is the term about conflict of interest?
              else if (notArray[k].search(/\[coi/i) >= 0){
                    notArray[k] = formatJournalPTO(notArray[k]);
                    warningArray[warningIndex] = "null";
              }

              //is the term a date?
              else if (notArray[k].search(/\[Date/i) >= 0 || notArray[k].search(/\[mhda/i) >= 0 || notArray[k].search(/\[crdt/i) >= 0 || notArray[k].search(/\[edat/i) >= 0){
                    outputReceiver = formatDatePTO(notArray[k]);
                    notArray[k] = outputReceiver[0];
                    warningArray[warningIndex] = outputReceiver[1];
              }
							else if (notArray[k].search(/\[dcom/i) >= 0 || notArray[k].search(/\[lr/i) >= 0 || notArray[k].search(/\[dp/i) >= 0 || notArray[k].search(/\[pdat/i) >= 0){
                    outputReceiver = formatDatePTO(notArray[k]);
                    notArray[k] = outputReceiver[0];
                    warningArray[warningIndex] = outputReceiver[1];
              }

              //is the term a keyword?
              else if (notArray[k].search(/\[ti/i) >= 0 || notArray[k].search(/\[All/i) >= 0 || notArray[k].search(/\[ot/i) >= 0 || notArray[k].search(/\[tt/i) >= 0){
                    //testingArray[testingIndex] = "kw";
                    outputReceiver = formatKeywordPTO(notArray[k], uPref);
                    notArray[k] = outputReceiver[0];
                    //warningArray[warningIndex] = warningArray[warningIndex] + outputReceiver[1];
                    warningArray[warningIndex] = outputReceiver[1];
              }

              //is the term a keyword with a TW tag?
              else if (notArray[k].search(/\[tw/i) >= 0 || notArray[k].search(/\[text word/i) >= 0){
                    outputReceiver = formatKeywordPTO(notArray[k], uPref);
                    notArray[k] = outputReceiver[0];
                    //warningArray[warningIndex] = warningArray[warningIndex] + outputReceiver[1];
                    warningArray[warningIndex] = outputReceiver[1];
              }

              //is the term a language limit?
              else if (notArray[k].search(/\[la/i) >= 0){
                    outputReceiver = formatLimitPTO(notArray[k]);
                    notArray[k] = outputReceiver[0];
                    warningArray[warningIndex] = outputReceiver[1];
              }

	      //is the term a citation number?
              else if (notArray[k].search(/\[ip\]/i) >= 0 || notArray[k].search(/\[issue\]/i) >= 0 || notArray[k].search(/\[pg\]/i) >= 0 || notArray[k].search(/\[pagination\]/i) >= 0 || notArray[k].search(/\[vi\]/i) >= 0){
                    notArray[k] = formatCitationPTO(notArray[k]);
              }

              //is the term an ID number?
              else if (notArray[k].search(/\[pmid/i) >= 0 || notArray[k].search(/\[uid/i) >= 0 || notArray[k].search(/\[auid/i) >= 0 || notArray[k].search(/\[jid/i) >= 0){
                    notArray[k] = formatIdNumbersPTO(notArray[k]);
                    warningArray[warningIndex] = "null";
              }
              else if (notArray[k].search(/\[gr/i) >= 0 || notArray[k].search(/\[si/i) >= 0 || notArray[k].search(/\[se/i) >= 0 || notArray[k].search(/\[is/i) >= 0){
                    notArray[k] = formatIdNumbersPTO(notArray[k]);
                    warningArray[warningIndex] = "null";
              }
              else if (notArray[k].search(/\[lid/i) >= 0 || notArray[k].search(/\[aid/i) >= 0 || notArray[k].search(/\[rn/i) >= 0 || notArray[k].search(/\[ec\/rn/i) >= 0){
                    notArray[k] = formatIdNumbersPTO(notArray[k]);
                    warningArray[warningIndex] = "null";
              }

              //is the term a subset limit?
              else if (notArray[k].search(/\[sb/i) >= 0){
                    outputReceiver = formatLimitPTO(notArray[k]);
                    notArray[k] = outputReceiver[0];
                    warningArray[warningIndex] = outputReceiver[1];
              }

              //is the term a text limit?
              else if (notArray[k].search(/\[text\]/i) >= 0){
                    outputReceiver = formatLimitPTO(notArray[k]);
                    notArray[k] = outputReceiver[0];
                    warningArray[warningIndex] = outputReceiver[1];
              }

              //does the term have an unrecognised tag?
              else if (notArray[k].search(/\[/) >= 0){
                  warningArray[warningIndex] = "This term did not have a recognised tag/syntax. If it is a term related to the year or date, my apologies - this will be coming soon.";
                  warningArray[warningIndex] = warningArray[warningIndex].fontcolor("red");
              }

              else {
                    //testingArray[testingIndex] = "nosyntax";
                    //check to see if it is a jsubset without a tag
                    if (notArray[k].search(/jsubset/i) >= 0){
                      notArray[k] = notArray[k] + "[text]";
                      outputReceiver = formatLimitPTO(notArray[k]);
                      notArray[k] = outputReceiver[0];
                      warningArray[warningIndex] = outputReceiver[1];
                    }

									//check to see if it is a pmc ID term, which do not require tags
		    			else if (notArray[k].search(/PMC/i) >=0){
                      notArray[k] = notArray[k] + ".pm.";
		    				}

							// check to see if it's a line number
							else if (notArray[k].search("#") >= 0) {
									notArray[k] = notArray[k].replace(/#/g,"");
							}

								//otherwise, assume the term is a bare keyword, and make it an all fields search, but throw a warning.
              else if (notArray[k].search(/\w/) >= 0) { // if it contains any alphanumeric character (ie not empty)
                      notArray[k] = notArray[k] + ".af.";
                      notArray[k] = notArray[k].fontcolor("red");
                      warningArray[warningIndex] = "This term did not have a tag. For simplicity, it has been translated as an \"all fields\" search in Ovid syntax. However, this may not be an accurate translation. For the most accurate translation, please enter this term into the PubMed interface, and look on the right-hand side of your results. Copy the text in the Search Details display and enter it into Transpose for an accurate translation into Ovid syntax. ";
                      warningArray[warningIndex] = warningArray[warningIndex].fontcolor("red");
                  }

								else {
									// do nothing
								}
						}

						// deal with any lingering line numbers
						if (notArray[k].search("#") >= 0) {
								notArray[k] = notArray[k].replace(/#/g,"");
						}


              //add the parentheses back in
              if (parenArray.length > 1){
                if (parenArray[0].search(/\(/) >= 0){
                  parenArray[1] = notArray[k];
                }
                else{
                  parenArray[0] = notArray[k];
                }
                notArray[k] = parenArray.join("");
              }
              testingIndex++;
              warningIndex++;
              //document.getElementById("output1").innerHTML = parenArray.length;
            } // this corresponds to the not for-loop
            andArray[j] = notArray.join(" not ");
        } //this corresponds to the and for-loop
        orArray[i] = andArray.join(" and ");
    }//this corresponds to the or for-loop
    lineArray[h] = orArray.join(" or ");
	}//this corresponds to the linebreak for-loop
	outputline = lineArray.join("<br />");

    //if (filterArray.length > 1){
     //split the string by any semicolons and put the pieces into an array
            //var limitArray = filterArray[1].split("; ");
            //var limitLength = limitArray.length;
            //var l;

            // go through each element in the array
            //for (l = 0; l < limitLength; l++){

                //this checks for the attributes of the search term.

            //} // this corresponds to the limit for-loop
    //} // filter for-loop

    //outputline = filterArray.join("<br />");

    //document.getElementById("output1").innerHTML = inputline;
  	//document.getElementById("output2").innerHTML = testingArray;
    document.getElementById("output3").innerHTML = outputline;

    var warningString = "<table border=\"1\"><tr><td>Item in strategy</td><td>Warnings are in red and suggestions are in blue</td></tr>";
    var warningFound = 0;

    //goes through the warning array and reformats into an HTML table. Is warningIndex the correct end-loop?
    for (wi = 0; wi < warningIndex; wi++){
        wiPlus = wi + 1;
        //if there were no warnings for this term
        if (warningArray[wi] == "null" || warningArray[wi] == undefined){
            //do nothing
        }
        //if there were warnings for this term, reformat them in HTML.
        else{
          for (wii = 0; wii < wsli; wii++){
            if (warningArray[wi] == warningShortlist[wii]){
              warningShortlistItemNos[wii] = warningShortlistItemNos[wii] + ", " + wiPlus;
              warningFound = 1;
            }
          }
          if (warningFound == 0){
            warningShortlist[wsli] = warningArray[wi];
            warningShortlistItemNos[wsli] = wiPlus;
            wsli++;
          }
          else{
            warningFound = 0;
          }
        }
    } //this corresponds to the for-loop that reformats the warningArray into an HTML table.
    for (wiii = 0; wiii < wsli; wiii++){
      warningString = warningString + "<tr><td>" + warningShortlistItemNos[wiii] + "</td><td>" + warningShortlist[wiii] + "</td></tr>";
    }

    //if there were no warnings at all, we don't need a table.
    if (warningString == "<table><tr><td>Item in strategy</td><td>Warning or suggestion</td></tr>"){
	warningString = "No warnings for this strategy";
    }
    //if there were warnings, we need to close the table.
    else{
        warningString = warningString + "</table>";
    }


    document.getElementById("output4").innerHTML = warningString;

}  //this corresponds to the function declaration

//****************************************************************************************************MeSH*******************************************************************

function formatMeshPTO (fmString) {
    //make an array to receive the output of the subheading function and split it into output and warnings
    var fmOutputReceiver = [null, null];

    //make a variable to hold any warnings
    var fmWarning = "null";

    //make an array to hold the outputs (string and warnings)
    var fmOutputArray = [null, null];

    //make an array to hold the subheadings, if any
    var fmSubheadings = [null, null];
    var fmParens = [null, null];
    var parens = 0;

    // check if the string has a leading parenthesis - the double equals means only in the first position
    if (fmString.search(/\(/) == 0){

        //if the term is focussed, convert to Ovid syntax
        if (fmString.search(/\[Majr/i) >= 0){
            fmString = fmString.replace(/^\(+/,'$& *');
        }
        //if NoExp is not found, add the Ovid syntax to explode - note the less than means not found
        if (fmString.search(/:NoExp/i) < 0){
            fmString = fmString.replace(/^\(+/,'$&exp ');
        }
    }

    //if there is no leading parenthesis
    else{

        //if the term is focussed, convert to Ovid syntax
        if (fmString.search(/\[Majr/i) >= 0){
            fmString = "*" + fmString;
        }

        //if NoExp is not found, add the Ovid syntax to explode - note the less than means not found
        if (fmString.search(/:NoExp/i) < 0){
            fmString = "exp " + fmString;
        }
    }

    //if NoExp is found, now we remove it
    if (fmString.search(/:NoExp/i) >= 0){
       fmString = fmString.replace(/:NoExp/i,"");
    }

    //if there is a slash, we process the subheadings
    if (fmString.search(/\//i) >= 0){

        //take off the end tag
        fmString = fmString.replace(/\[M[\w| ]+\]/i,"");

        //split the Mesh term into its Mesh term and its subheading
        fmSubheadings = fmString.split("\/");

        //remove any quotes from the subheading
        fmSubheadings[1] = fmSubheadings[1].replace(/"/g,"");

        //check for trailing parentheses
        //if (fmSubheadings[1].search(/\)/) >= 0){
          //fmParens = fmSubheadings[1].split("\)");
          //fmSubheadings[1] - fmParens[1];
          //parens = 1;
        //}

        //if the subheading is a full word, not a 2-letter code
        if (fmSubheadings[1].length > 2){
            //hand the subheading to the formatSubheading function for processing
            fmOutputReceiver = formatSubheadingsPTO(fmSubheadings[1]);
            fmSubheadings[1] = fmOutputReceiver[0];
            fmWarning = fmOutputReceiver[1];
        }

        //check whether the MeSH term contains stop words, and add or remove quotes accordingly
        if (fmSubheadings[0].search(/ and /i) >= 0){
            fmSubheadings[0] = fmSubheadings[0] + "\"";
        }
        else if (fmSubheadings[0].search(/ or /i) >= 0){
            fmSubheadings[0] = fmSubheadings[0] + "\"";
        }
        else if (fmSubheadings[0].search(/ use /i) >= 0){
            fmSubheadings[0] = fmSubheadings[0] + "\"";
        }
        else{
            fmSubheadings[0] = fmSubheadings[0].replace(/"/g,"");
        }

        //join the processed subheading back onto the MeSH term
        fmString = fmSubheadings.join("\/");
        //if (parens == 1){
          //fmParens[0] = fmString;
          //fmString = fmParens.join("\)");
        //}
    }

    //if there isn't a subheading
    else{
        //take off the end tag
        fmString = fmString.replace(/\[M[\w| ]+\]/i,"/");

        //if there are quotes
        if (fmString.search(/"/) >= 0){

            //check for stopwords - if there are none, remove the quotes
            if (fmString.search(/ and /i) >= 0){
                //do nothing
            }
            else if (fmString.search(/ or /i) >= 0){
                //do nothing
            }
            else if (fmString.search(/ use /i) >= 0){
                //do nothing
            }
            //otherwise, remove the quotes
            else{
                fmString = fmString.replace(/"/g,"");
            }
        }
    }
    //package up the results ready to be returned
    fmOutputArray[0] = fmString;
    fmOutputArray[1] = fmWarning;
    return fmOutputArray;
}

//*******************************************************************************************Controlled Non-Mesh**************************************************************

function formatControlledPTO(cvString) {

    //make a variable to hold any warnings
    var cvWarning = "null";

    //make an array to hold the outputs (string and warnings)
    var cvOutputArray = [null, null];

	//make temporary variables for the supplementary concept word split
	var tempCV = "null";

    //reformat publication types (three variants)

    if (cvString.search(/\[pt/i) >= 0 || cvString.search(/\[publication/i) >= 0){
	//if it is unexploded, you can use the Ovid field tag.
      	if (cvString.search(/:NoExp/i) >= 0){
		cvString = cvString.replace(/\[ptyp:NoExp\]/i,".pt.");
        	cvString = cvString.replace(/\[Publication Type:NoExp\]/i,".pt.");
        	cvString = cvString.replace(/\[pt:NoExp\]/i,".pt.");
        	cvString = removeQuotesPTO(cvString);
        }
	//in Ovid, to get an exploded Publication Type, you can enter it as if it were a MeSH term.
	else{
        	cvString = cvString.replace(/\[ptyp\]/i,"/");
        	cvString = cvString.replace(/\[Publication Type\]/i,"/");
        	cvString = cvString.replace(/\[pt\]/i,"/");
       	 	cvOutputArray[1] = cvString.replace(/\//,"");
       	 	cvString = removeQuotesPTO(cvString);
		// check if the string has a leading parenthesis - the double equals means only in the first position
        	if (cvString.search(/\(/) == 0){
            		cvString = cvString.replace(/^\(+/,'$&exp ');
        	}
		//if there is no leading parenthesis
        	else{
            		cvString = "exp " + cvString;
        	}
        	cvWarning = "In PubMed, Publication Types are exploded, and this Ovid search replicates the explosion. If you prefer not to explode this term, please use " + cvOutputArray[1] + ".pt. instead.";
        	cvWarning = cvWarning.fontcolor("blue");
    	}
	cvOutputArray[0] = cvString;
	cvOutputArray[1] = cvWarning;
    }
    //reformat subheadings to exploded subheadings in Ovid syntax
    else if (cvString.search(/\[sh\]/i) >= 0 || cvString.search(/\[subheading\]/i) >= 0){
        cvString = cvString.replace(/\[sh\]/i,"");
        cvString = removeQuotesPTO(cvString);
        cvOutputArray = formatSubheadingsPTO(cvString);
        cvOutputArray[0] = cvOutputArray[0].replace(/\"/,"");
        //this checks to see if there are narrower term subheadings and chops them off if there are. This is just for efficiency.
        if (cvOutputArray[0].length == 0){
            cvOutputArray[0] = "\[Please see warning below\]";
        }
        else{
            cvOutputArray[0] = cvOutputArray[0].slice(0,2);
            cvOutputArray[0] = cvOutputArray[0] + ".xs.";
        }
    }

    //unexploded subheadings are simpler
    else if (cvString.search(/\[sh:noexp\]/i) >= 0 || cvString.search(/\[subheading:noexp\]/i) >= 0){
        cvString = cvString.replace(/\[sh:noexp\]/i,".fs.");
        cvString = cvString.replace(/\[subheading:noexp\]/i,".fs.");
        cvString = removeQuotesPTO(cvString);
        cvOutputArray[0] = cvString;
    }

	//reformats supplementary concepts - not exactly, but as closely as possible with the Ovid interface.
	else if (cvString.search(/\[supp/i) >= 0 || cvString.search(/\[nm/i) >= 0){
		cvString = cvString.replace(/\[supplementary concept\]/i,"");
		cvString = cvString.replace(/\[nm\]/i,"");
		if (cvString.search(/ /) >= 0){
			cvString = cvString.replace(/^"/,"(");
			cvString = cvString.replace(/"$/,")");
			tempCV = cvString;
			cvString = cvString + ".rs,ps.";
			tempCV = tempCV.replace(/ /," and ");
			tempCV = tempCV + ".nm,rn,rx,px."
			cvString = "(" + cvString + " or " + tempCV + ")";
			cvWarning = "This is an approximate translation of the supplementary concept tag in PubMed. Ovid MEDLINE fields which accept a phrase have been converted exactly. Ovid MEDLINE fields which accept only individual words have been split up with a boolean AND, but you may wish to adjust the individual words used.";
			cvWarning = cvWarning.fontcolor("red");
		}
		else{
			cvString = removeQuotesPTO(cvString);
			cvString = cvString + ".nm,rn,rs,rx,ps,px.";
			cvWarning = "This is a close translation of the supplementary concept tag in PubMed. However, results may vary slightly.";
			cvWarning = cvWarning.fontcolor("blue");
		}
		cvOutputArray[0] = cvString;
		cvOutputArray[1] = cvWarning;
	}

	//reformats "personal name as subject" strategies.
	else if (cvString.search(/\[subject/i) >= 0 || cvString.search(/\[ps/i) >= 0){
		cvString = cvString.replace(/\[Subject\W{1,3}Personal Name]/i,".pn.");
		cvString = cvString.replace(/\[ps]/i,".pn.");
		cvString = removeQuotesPTO(cvString);
		cvOutputArray[0] = cvString;
		cvOutputArray[1] = cvWarning;
	}

	//reformats Affiliation, address, or institution strategies
	else if (cvString.search(/\[Affiliation/i) >= 0 || cvString.search(/\[ad/i) >= 0){
		cvString = cvString.replace(/\[Affiliation]/i,".in.");
		cvString = cvString.replace(/\[ad]/i,".in.");
		cvString = removeQuotesPTO(cvString);
		cvOutputArray[0] = cvString;
		cvOutputArray[1] = cvWarning;
	}

    return cvOutputArray;
}

//****************************************************************************************************Authors*******************************************************************
 function formatAuthorPTO(auString){

     //make a variable to hold any warnings
    var auWarning = "null";

    //make an array to hold the outputs (string and warnings)
    var auOutputArray = [null, null];

	//check for a full name search for author
	if (auString.search(/\[Author\W{1,3}Full/i) >= 0){
		auString = auString.replace(/\[Author\W{1,3}Full\]/i,".fa.");
		auString = removeQuotesPTO(auString);
	}
	else if (auString.search(/\[fau/i) >= 0){
    		auString = auString.replace(/\[fau\]/i,".fa.");
		auString = removeQuotesPTO(auString);
	}
	else if (auString.search(/\[Author\W{1,3}First/i) >= 0){
    		if (auString.search(/ /) >= 0){
      			auString = auString.replace(/\[Author\W{1,3}First\]/i,".pa.");
    		}
    		else{
      			auString = auString.replace(/\[Author\W{1,3}First\]/i," $.pa.");
    		}
		auString = removeQuotesPTO(auString);
	}
	else if (auString.search(/\[1au/i) >= 0){
    		if (auString.search(/ /) >= 0){
      			auString = auString.replace(/\[1au\]/i,".pa.");
   		}
    		else{
      			auString = auString.replace(/\[1au\]/i," $.pa.");
    		}
		auString = removeQuotesPTO(auString);
	}
	else if (auString.search(/\[Author\W{1,3}Identifier/i) >= 0){
		auString = auString.replace(/\[Author\W{1,3}Identifier\]/i,".ai.");
		auString = removeQuotesPTO(auString);
	}
	else if (auString.search(/\[Author\W{1,3}Corporate/i) >= 0 || auString.search(/\[cn/i) >= 0){
		auString = auString.replace(/\[Author\W{1,3}Corporate\]/i,".fa,au.");
		auString = auString.replace(/\[cn\]/i,".fa,au.");
		auString = removeQuotesPTO(auString);
	}
	else if (auString.search(/\[Author\W{1,3}Last/i) >= 0 || auString.search(/\[lastau/i) >= 0){
		auString = auString.replace(/\[Author\W{1,3}Last\]/i,".fa,au.");
		auString = auString.replace(/\[lastau\]/i,".fa,au.");
		auString = removeQuotesPTO(auString);
		auWarning = "Last Author search not available in Ovid. The closest approximation is to search in the author or full author.";
		auWarning = auWarning.fontcolor("blue");
	}
	else if (auString.search(/\[ir/i) >= 0 || auString.search(/\[investigator/i) >= 0){
		auString = auString.replace(/\[investigator\]/i,".ir.");
		auString = auString.replace(/\[ir\]/i,".ir.");
		auString = removeQuotesPTO(auString);
	}
	else{
    if (auString.search(/ /) >= 0){
      auString = auString.replace(/\[Author\]/i,".au.");
      auString = auString.replace(/\[Au\]/i,".au.");
    }
    else{
      auString = auString.replace(/\[Author\]/i," $.au.");
      auString = auString.replace(/\[Au\]/i," $.au.");
    }

		auString = removeQuotesPTO(auString);
	}
	auOutputArray[0] = auString;
	auOutputArray[1] = auWarning;
	return auOutputArray;

}

//****************************************************************************************************Citation*******************************************************************
 function formatCitationPTO(citString){

     //make a variable to hold any warnings
    //var citWarning = "null";

    //make an array to hold the outputs (string and warnings)
    //var citOutputArray = [null, null];

	//check for a volume number search
	if (citString.search(/\[vi/i) >= 0){
		citString = citString.replace(/\[vi\]/i,".vp.");
		citString = removeQuotesPTO(citString);
	}
  //check for an issue number search
  else if (citString.search(/\[ip/i) >= 0){
    citString = citString.replace(/\[ip\]/i,".ip.");
		citString = removeQuotesPTO(citString);
	}
  else if (citString.search(/\[issue/i) >= 0){
    citString = citString.replace(/\[issue\]/i,".ip.");
    citString = removeQuotesPTO(citString);
  }
  //check for a page number search
  else if (citString.search(/\[pg/i) >= 0){
    citString = citString.replace(/\[pg\]/i,".pg.");
		citString = removeQuotesPTO(citString);
	}
  else if (citString.search(/\[pagination/i) >= 0){
    citString = citString.replace(/\[pagination\]/i,".pg.");
		citString = removeQuotesPTO(citString);
	}

	//citOutputArray[0] = citString;
	//citOutputArray[1] = citWarning;
	return citString;

}

//****************************************************************************************************Journal*******************************************************************

function formatJournalPTO(jnString) {

    //reformat journal title
    if (jnString.search(/\[jour/i) >= 0){
	jnString = jnString.replace(/\[jour\]/i,".jn,ja,es,il,is.");
        jnString = jnString.replace(/\[journal\]/i,".jn,ja,es,il,is.");
    }
    //reformat title abbreviation
    else if (jnString.search(/\[ta/i) >= 0){
        jnString = jnString.replace(/\[ta\]/i,".ja,es,il,is.");
    }
    //reformat place of publication
    if (jnString.search(/\[pl/i) >= 0){
        jnString = jnString.replace(/\[pl\]/i,".cp.");
    }
    //reformat publisher
    else if (jnString.search(/\[pubn/i) >= 0){
        jnString = jnString.replace(/\[pubn\]/i,".pb.");
    }
    //reformat editor
    else if (jnString.search(/\[ed/i) >= 0){
        jnString = jnString.replace(/\[ed\]/i,".ee.");
        jnString = jnString.replace(/\[editor\]/i,".ee.");
    }
    //reformat conflict of interest information
    else if (jnString.search(/\[coi/i) >= 0){
        jnString = jnString.replace(/\[coi\]/i,".ci.");
        jnString = jnString.replace(/\[cois\]/i,".ci.");
    }

    return jnString;
}

//****************************************************************************************************Dates*******************************************************************

function formatDatePTO(dtString) {

  //make a variable to hold any warnings
 var dtWarning = "null";

 //make an array to hold the outputs (string and warnings)
 var dtOutputArray = [null, null];

 var year1 = 0;
 var month1 = 0;
 var day1 = 0;
 var year2 = 0;
 var month2 = 0;
 var day2 = 0;
 var string1 = 0;
 var string2 = 0;
 var tagValue = "";
 var assembleDates = "(";
 var endDay = 31;
 var endMonth = 12;
 var endYear = 3000;
 var startMonth = 1;
 var startDay = 1;
 var yearFlip = 0;
 var monthFlip = 0;
 var dayFlip = 0;
 var monthLead = "";
 var dayLead = "";
 var spacingVar = 1;

 //change the long form tags to short form tags
 if (dtString.search(/\[Date/i) >= 0){
	 dtString = dtString.replace(/Date\W{1,3}Completion/ig,"dcom");
	 dtString = dtString.replace(/Date\W{1,3}Create/ig,"crdt");
	 dtString = dtString.replace(/Date\W{1,3}Entrez/ig,"edat");
	 dtString = dtString.replace(/Date\W{1,3}Mesh/ig,"mhda");
	 dtString = dtString.replace(/Date\W{1,3}Modification/ig,"lr");
	 dtString = dtString.replace(/Date\W{1,3}Publication/ig,"dp");
 }
//remove quotes
dtString = dtString.replace(/\"/g,"");
//check for date ranges
if (dtString.search(/\]\s?:\s?/i) >= 0){
	//this takes the range and chops it into two values, start and end
	var dateArray = dtString.split(":");
	string1 = dateArray[0];
	string2 = dateArray[1];
	//this chops the tag off the end of the dates and stores it in a variable
	dateArray = string1.split("\[");
	string1 = dateArray[0];
	dateArray = string2.split("\[");
	string2 = dateArray[0];
	tagValue = dateArray[1];
	if (tagValue == "dcom]" || tagValue == "lr]"){
		spacingVar = 0;
	}
	//this checks for month and day values in the dates
	if (dtString.search(/\//) >= 0){
		var stringArray = string1.split("/");
		year1 = Number(stringArray[0]);
	  month1 = Number(stringArray[1]);
		//this checks for months without days
		if (stringArray[2] == null){
			day1 = 0;
		}
		else{
			day1 = Number(stringArray[2]);
		}
		stringArray = string2.split("/");
		year2 = Number(stringArray[0]);
		month2 = Number(stringArray[1]);
		if (stringArray[2] == null){
			day2 = 0;
		}
		else{
			day2 = Number(stringArray[2]);
		}
	}
	//if there is only a year value
	else{
		year1 = Number(string1);
		year2 = Number(string2);
	}
	if (year1 > year2){
		//flip the two dates so that the earlier one is first
		yearFlip = year2;
		monthFlip = month2;
		dayFlip = day2;
		year2 = year1;
		month2 = month1;
		day2 = day1;
		year1 = yearFlip;
		month1 = monthFlip;
		day1 = dayFlip;
		dtWarning = "The date range which you entered is backwards. The range has been flipped so that the earlier date is first. This should not affect the accuracy of the search, but you may wish to check your original search strategy."
		dtWarning = dtWarning.fontcolor("blue");
	}
	else if (year1 == year2 && month1 > month2){
		//flip the months so that the earlier one is first.
		monthFlip = month2;
		dayFlip = day2;
		month2 = month1;
		day2 = day1;
		month1 = monthFlip;
		day1 = dayFlip;
		dtWarning = "The date range which you entered is backwards. The range has been flipped so that the earlier date is first. This should not affect the accuracy of the search, but you may wish to check your original search strategy."
		dtWarning = dtWarning.fontcolor("blue");
	}
	else if (year1 == year2 && month1 == month2 && day1 > day2){
		//flip the days so that the earlier one is first.
		dayFlip = day2;
		day2 = day1;
		day1 = dayFlip;
		dtWarning = "The date range which you entered is backwards. The range has been flipped so that the earlier date is first. This should not affect the accuracy of the search, but you may wish to check your original search strategy."
		dtWarning = dtWarning.fontcolor("blue");
	}

	if (day1 == 0 || day1 == 1){
		//do nothing
	}
	else {
		if (year1 == year2 && month1 == month2){
			endDay = day2;
		}
		else{
			if (month1 == 4 || month1 == 6 || month1 == 9 || month1 == 11){
				endDay = 30;
			}
			else if (month1 == 2){
				endDay = 29;
			}
		}
		if (day1 <= endDay){
			while (day1 <= endDay){
				//Ovid requires a two-digit number for months and days. Check for single-digit numbers and add a leading zero if needed
				monthLead = month1.toString();
				dayLead = day1.toString();
				if (monthLead.length < 2){
					monthLead = "0" + monthLead;
				}
				if (dayLead.length < 2){
					dayLead = "0" + dayLead;
				}
				//this takes each day starting with the value in day1, and adds the date to the string, ending with the last day of the month or range
				//it also checks to see if spacing is needed within the date value and adds it if necessary
				if (spacingVar == 0){
					assembleDates = assembleDates + year1.toString() + monthLead + dayLead + "* or ";
				}
				else{
					assembleDates = assembleDates + year1.toString() + " " + monthLead + " " + dayLead + "* or ";
				}
				day1++;
			} //this corresponds to the while loop
		} //this corresponds to the if day1 less than endDay
		else{
			dtWarning = "Warning! Date range error. This can occur with an erroneous date entry, such as Feb 30th. Please check your date ranges carefully."
			dtWarning = dtWarning.fontcolor("red");
		}
	} //this corresponds to the else which meant day1 was not 1 or 0
	if (month1 == 0 || (month1 == 1 && day1 == 1 && year1 < year2) || (month1 == 1 && day1 == 0)){
			//this means month is irrelevant - do nothing
			//assembleDates = assembleDates + year1.toString() + "* or ";
	}
	else{
		if (day1 == 1){
			//this means that no days were added to the string, and therefore the month must be included.
			//Ovid requires a two-digit number for months and days. Check for single-digit numbers and add a leading zero if needed
			//it also checks to see if spacing is needed within the date value and adds it if necessary
			monthLead = month1.toString();
			if (monthLead.length < 2){
				monthLead = "0" + monthLead;
			}
			if (spacingVar == 0){
				assembleDates = assembleDates + year1.toString() + monthLead + "* or ";
			}
			else{
				assembleDates = assembleDates + year1.toString() + " " + monthLead + "* or ";
			}
			month1++;
		} //this corresponds to if day1 equal 1
		else{
			//this means that the days were added to the string already, so the month should not be included.
			if (month1 == endMonth){
				//do nothing
			}
			else{
				month1++;
			}
		}
		//now we add any months to the string...
		if (year1 == year2){
			//this means that end month is determined by the second value in the range
			endMonth = month2;
		}
		if (month1 <= endMonth){
			while (month1 <= endMonth){
				//Ovid requires a two-digit number for months and days. Check for single-digit numbers and add a leading zero if needed
				monthLead = month1.toString();
				if (monthLead.length < 2){
					monthLead = "0" + monthLead;
				}
				//this takes each month starting with the value in month1, and adds the date to the string, ending with December or the last month of the range.
				//it also checks to see if spacing is needed within the date value and adds it if necessary
				if (spacingVar == 0){
					assembleDates = assembleDates + year1.toString() + monthLead + "* or ";
				}
				else{
					assembleDates = assembleDates + year1.toString() + " " + monthLead + "* or ";
				}
				month1++;
			} //this corresponds to while loop
		} //this corresponds to if year1 == year2
		else{
			dtWarning = "Warning! Date range error. This can occur with an erroneous date entry, for example if a month value is higher than 12. Please check your date ranges carefully."
			dtWarning = dtWarning.fontcolor("red");
		}
	}
	if (month1 == 0 || (month1 == 1 && day1 == 0) || (month1 == 1 && day1 == 1)){
		//do nothing
	}
	else {
		year1++;
	}
	//replace the automatic "current year" from PubMed with the actual current year
	if (year2 == 3000){
		year2 = (new Date()).getFullYear();
	}
	if (month2 == 0 || (month2 == 12 && day2 == 0) || (month2 == 12 && day2 == 31)){
		endYear = year2;
	}
	else {
		endYear = year2;
		endYear--;
	}
	//now we add any years to the string...
	if (year1 <= endYear){
		while (year1 <= endYear){
			//this takes each year starting with the value in year1, and adds the date to the string, ending with the last year of the range
			assembleDates = assembleDates + year1.toString() + "* or ";
			year1++;
		}
	}
	if (endYear < year2){
		if (month2 == 12 && day2 == 31){
			//do nothing
		}
		else{
			if (month2 > 1 || (month2 == 1 && day2 == 31)){
				var thisMonth = 1;
				while (thisMonth < month2){
					//Ovid requires a two-digit number for months and days. Check for single-digit numbers and add a leading zero if needed
					monthLead = thisMonth.toString();
					if (monthLead.length < 2){
						monthLead = "0" + monthLead;
					}
					assembleDates = assembleDates + year2.toString() + monthLead.toString() + "* or ";
					thisMonth++;
				}
			}
			var lastDay = 31;
			if (month2 == 2){
				lastDay = 29;
			}
			else if (month2 == 4 || month2 == 6 || month2 == 9 || month2 == 11){
				lastDay = 30;
			}
			if (day2 == lastDay || (month2 == 2 && day2 == 28)){
				//Ovid requires a two-digit number for months and days. Check for single-digit numbers and add a leading zero if needed
				monthLead = thisMonth.toString();
				if (monthLead.length < 2){
					monthLead = "0" + monthLead;
				}
				if (spacingVar == 0){
					assembleDates = assembleDates + year2.toString() + monthLead.toString() + "* or ";
				}
				else{
					assembleDates = assembleDates + year2.toString() + " " + monthLead.toString() + "* or ";
				}
			}
			else{
				var thisDay = 1;
				while (thisDay <= day2){
					monthLead = month2.toString();
					dayLead = thisDay.toString();
					if (monthLead.length < 2){
						monthLead = "0" + monthLead;
					}
					if (dayLead.length < 2){
						dayLead = "0" + dayLead;
					}
					//this takes each day starting with the value in day1, and adds the date to the string, ending with the last day of the month or range
					//it also checks to see if spacing is needed within the date value and adds it if necessary
					if (spacingVar == 0){
						assembleDates = assembleDates + year1.toString() + monthLead + dayLead + "* or ";
					}
					else{
						assembleDates = assembleDates + year1.toString() + " " + monthLead + " " + dayLead + "* or ";
					}
					thisDay++;
				}
			}
		}
	}
	//dtString = dtString.replace(/Date\W{1,3}Completion/ig,"dcom");
	assembleDates = assembleDates.replace(/ or $/i,"\)");
	dtString = assembleDates + "[" + tagValue;
	}
    //reformat date completed or revision date
    if (dtString.search(/\[dcom/i) >= 0 || dtString.search(/\[lr/i) >= 0){
        if (dtString.length < 16){
					dtString = dtString.replace(/\[dcom\]/i,"*.ed.");
					dtString = dtString.replace(/\[lr\]/i,"*.rd.");
        }
        else{
					dtString = dtString.replace(/\[dcom\]/i,".ed.");
					dtString = dtString.replace(/\[lr\]/i,".rd.");
        }
        dtString = dtString.replace(/\//g,"");
    }
		//reformat Mesh Date or date of publication
    if (dtString.search(/\[mhda/i) >= 0 || dtString.search(/\[dp/i) >= 0 || dtString.search(/\[pdat/i) >= 0){
        if (dtString.length < 16){
          dtString = dtString.replace(/\[mhda\]/i,"*.da.");
					dtString = dtString.replace(/\[dp\]/i,"*.dp.");
					dtString = dtString.replace(/\[pdat\]/i,"*.dp.");
        }
        else{
          dtString = dtString.replace(/\[mhda\]/i,".da.");
					dtString = dtString.replace(/\[dp\]/i,".dp.");
					dtString = dtString.replace(/\[pdat\]/i,".dp.");
        }
				dtString = dtString.replace(/\//g," ");
    }
    //reformat the create date and the entrez date (according to current Ovid backwards configuration)
    else if (dtString.search(/\[edat/i) >= 0 || dtString.search(/\[crdt/i) >= 0){
        if (dtString.length < 22){
          dtString = dtString.replace(/\[edat\]/i,"*.dt.");
          dtString = dtString.replace(/\[crdt\]/i,"*.ez.");
        }
        else{
          dtString = dtString.replace(/\[edat\]/i,".dt.");
          dtString = dtString.replace(/\[crdt\]/i,".ez.");
        }
        dtString = dtString.replace(/\//g," ");
        dtWarning = "The value of [crdt] corresponds to the value of Entrez Date in Ovid, and the value of [edat] corresponds to the value of Create Date in Ovid. I have emailed Ovid about this but have received no response."
        dtWarning = dtWarning.fontcolor("blue");
    }
    dtOutputArray[0] = dtString;
    dtOutputArray[1] = dtWarning;

    return dtOutputArray;
}


//****************************************************************************************************Keywords*******************************************************************

function formatKeywordPTO(kwString, uPref) {

    //make a variable to hold any warnings
    var fkwWarning = "null";

    //make an array to hold the outputs (string and warnings)
    var fkwOutputArray = [null, null];

    //reformat keywords being searched in the title
    if (kwString.search(/\[ti\]/i) >= 0 || kwString.search(/\[title\]/i) >= 0){
	kwString = kwString.replace(/\[title\]/i,".ti,bt.");
	kwString = kwString.replace(/\[ti\]/i,".ti,bt.");
	kwString = removeQuotesPTO(kwString);
    }
    //reformat keywords being searched in the title and abstract (with accuracy/efficiency options)
    else if (kwString.search(/\[tiab\]/i) >= 0 || kwString.search(/\[title/i) >= 0){
        if (uPref == 0){
	    kwString = kwString.replace(/\[tiab\]/i,".ti,ab,cl,oa,kw,kf.");
	    kwString = kwString.replace(/\[title\/abstract\]/i,".ti,ab,cl,oa,kw,kf.");
	    fkwWarning = "[tiab] or [title/abstract] tab in PubMed searches 4 additional fields besides the title and abstract. This conversion creates the most accurate translation in Ovid Medline syntax. This conversion creates the most accurate translation in Ovid Medline syntax - if you prefer something simpler, please choose the Efficiency option.";
	}
	else{
	    kwString = kwString.replace(/\[tiab\]/i,".ti,ab.");
	    kwString = kwString.replace(/\[title\/abstract\]/i,".ti,ab.");
	    fkwWarning = "[tiab] or [title/abstract] tab in PubMed searches 4 additional fields besides the title and abstract. This conversion creates an efficient translation for daily use - if you prefer something more accurate, please choose the Accuracy option.";
	    fkwWarning = fkwWarning.fontcolor("blue");
	    kwString = removeQuotesPTO(kwString);
	}
    }
    //reformat keywords being searched in the other title or translated title
    else if (kwString.search(/\[ot\]/i) >= 0 || kwString.search(/\[tt/i) >= 0){
        kwString = kwString.replace(/\[ot\]/i,".kw.");
        kwString = kwString.replace(/\[tt\]/i,".ot.");
        kwString = removeQuotesPTO(kwString);
    }
    //reformat keywords being searched in all fields
    else if (kwString.search(/\[All/i) >= 0){
        kwString = kwString.replace(/\[All fields\]/i,".af.");
	kwString = kwString.replace(/\[All\]/i,".af.");
	kwString = removeQuotesPTO(kwString);
    }

    //reformat keywords being searched in Text Words (with accuracy/efficiency options)
    else if (kwString.search(/\[tw/i) >= 0){
	if (uPref == 0){
		kwString = kwString.replace(/\[tw\]/i,".ti,ab,sh,hw,kw,rn,pn,sa,si.");
		//kwString = kwString.fontcolor("blue");
		fkwWarning = "This is a literal translation of the [tw] tag in PubMed. If you prefer something simpler, please choose the Efficiency option.";
	}
	else {
		kwString = kwString.replace(/\[tw\]/i,".mp.");
		//kwString = kwString.fontcolor("blue");
		fkwWarning = "This is an efficient but inexact translation of the [tw] tag. A literal translation of [tw] is .ti,ab,sh,hw,kw,rn,pn,sa,si. If you prefer a more accurate conversion, please choose the Accuracy option.";
	}
	fkwWarning = fkwWarning.fontcolor("blue");
	kwString = removeQuotesPTO(kwString);
    }
    //reformat keywords being searched in Text Words (with accuracy/efficiency options)
    else if (kwString.search(/\[text word/i) >= 0){
        if (uPref == 0){
		kwString = kwString.replace(/\[text word\]/i,".ti,ab,sh,hw,kw,rn,pn,sa,si.");
		kwString = kwString.fontcolor("blue");
		fkwWarning = "This is a literal translation of the [text word] tag in PubMed. If you prefer something simpler, please choose the Efficiency option.";
	}
	else {
		kwString = kwString.replace(/\[text word\]/i,".mp.");
		kwString = kwString.fontcolor("blue");
		fkwWarning = "This is an efficient but inexact translation of the [text word] tag. A literal translation of [tw] is .ti,ab,sh,hw,kw,rn,pn,sa,si. If you prefer a more accurate conversion, please choose the Accuracy option.";
	}
	fkwWarning = fkwWarning.fontcolor("blue");
	kwString = removeQuotesPTO(kwString);
    }

    //package up the results ready to be returned
    fkwOutputArray[0] = kwString;
    fkwOutputArray[1] = fkwWarning;
    return fkwOutputArray;
}

//****************************************************************************************************ID Numbers*******************************************************************

function formatIdNumbersPTO(idString) {

    //reformat pmid
    if (idString.search(/\[pmid/i) >= 0 || idString.search(/\[uid/i) >= 0){
        idString = idString.replace(/\[pmid\]/i,".ui.");
        idString = idString.replace(/\[uid\]/i,".ui.");
    }
    //reformat author ID
    else if (idString.search(/\[auid/i) >= 0){
        idString = idString.replace(/\[auid\]/i,".ai.");
    }
    //reformat NLM journal code
    else if (idString.search(/\[jid/i) >= 0){
        idString = idString.replace(/\[jid\]/i,".jc.");
    }
    //reformat grant information
    else if (idString.search(/\[gr/i) >= 0){
        idString = idString.replace(/\[gr\]/i,".gr,gc,gi,no,go.");
        idString = idString.replace(/\[grant number\]/i,".gr,gc,gi,no,go.");
    }
    //reformat secondary source ID
    else if (idString.search(/\[si/i) >= 0 || idString.search(/\[se/i) >= 0){
        idString = idString.replace(/\[si\]/i,".si.");
        idString = idString.replace(/\[secondary source id\]/i,".si.");
    }
    //reformat isbn information
    else if (idString.search(/\[is/i) >= 0){
        idString = idString.replace(/\[is\]/i,".ib.");
        idString = idString.replace(/\[isbn\]/i,".ib.");
    }
    //reformat aid and lid - ovid requires spaces rather than punctuation
    else if (idString.search(/\[lid/i) >= 0 || idString.search(/\[aid/i) >= 0){
        idString = idString.replace(/\[lid\]/i,"MYTEMPLID");
        idString = idString.replace(/\[aid\]/i,"MYTEMPAID");
        idString = idString.replace(/[.\/\(\)\[\]]/g," ");
        idString = idString.replace(/MYTEMPLID/i,".do,di.");
        idString = idString.replace(/MYTEMPAID/i,".id.");
    }
    //reformat ec/rn number
    else if (idString.search(/\[rn/i) >= 0 || idString.search(/\[ec\/rn number/i) >= 0){
        idString = idString.replace(/\[rn\]/i,".rn.");
        idString = idString.replace(/\[ec\/rn number\]/i,".rn.");
    }

    return idString;
}

//****************************************************************************************************Limits*******************************************************************

function formatLimitPTO(limString) {

  //make a variable to hold any warnings
  var limWarning = "null";

  //make an array to hold the outputs (string and warnings)
  var limOutputArray = [null, null];

  //make a variable to determine whether there is warning or not
  var limWarnYN = 0;

  //make a variable for outputs with quotes
  var limQuotes = 0;

    //reformat language limit
    if (limString.search(/\[lang/i) >= 0){
        limString = limString.replace(/\[lang\]/i,".lg.");
    }
    else if (limString.search(/\[la/i) >= 0){
        limString = limString.replace(/\[la\]/i,".lg.");
    }
    //is the term a subset search?
    else if (limString.search(/\[sb/i) >= 0){
        limString = limString.replace(/\[sb\]/i,"");
        limString = limString.replace(/"/g,"");
        limString = limString.toLowerCase();
        //compare the subheading to a list of all subheadings and convert to Ovid syntax, preserving explosions
         switch (limString){
             case "aids":
                 limString = "aids hiv journal.sb.";
                 break;
             case "all":
                 limString = "docz.dz.";
                 break;
             case "bioethics":
                 limString = "bioethics journals.sb.";
                 break;
             case "cancer":
                 limString = "limit [previous search] to cancer";
                 limWarnYN = 1;
                 break;
             case "cam":
                 limString = "limit [previous search] to Complementary Medicine";
                 limWarnYN = 1;
                 break;
             case "dietsuppl":
                 limString = "limit [previous search] to Dietary Supplements";
                 limWarnYN = 1;
                 break;
             case "history":
                 limString = '"history of medicine journals".sb.';
                 limQuotes = 1;
                 break;
             case "space":
                 limString = '"national aeronautics and space administration nasa journals".sb.';
                 limQuotes = 1;
                 break;
             case "systematic":
                 limString = "limit [previous search] to Systematic Reviews";
                 limWarnYN = 1;
                 break;
             case "tox":
                 limString = "limit [previous search] to Toxicology";
                 limWarnYN = 1;
                 break;
             case "veterinary":
                 limString = "limit [previous search] to Veterinary Science";
                 limWarnYN = 1;
                 break;
             case "free full text":
                 limString = "No equivalent! See Warning.";
                 limString = limString.fontcolor("blue");
                 limWarning = "Ovid Medline does not provide a limit for articles available in full text for free.";
                 break;
             case "full text":
                 limString = "limit [previous search] to full text";
                 limString = limString.fontcolor("blue");
                 limWarning = "This term should be applied as a limit in the Ovid interface. Please note that Ovid's full text filter is quite different from PubMed's. If you are attempting to compare output between the two databases, you may wish to remove all full text filters from both searches.";
                 break;
             case "pubmed pmc":
                 limString = "No equivalent! See Warning.";
                 limString = limString.fontcolor("blue");
                 limWarning = "Ovid Medline does not provide a limit for articles available in the PubMed Central collection.";
                 break;
             case "publisher":
                 limString = "limit [previous search] to publisher";
                 limString = limString.fontcolor("blue");
                 limWarning = "This term should be applied as a limit in the Ovid interface. Although this is the official translation for this term, in practice it often returns zero results in Ovid. You may wish to try using NOT medline.st. as an alternative.";
                 break;
             case "inprocess":
                 limString = "in process.st.";
                 break;
             case "medline":
                 limString = "medline.st.";
                 break;
             case "oldmedline":
                 limString = "oldmedline citations.sb.";
                 break;
             case "pubmednotmedline":
                 limString = '"pubmed not medline".st.';
                 break;
             case "indatareview":
                 limString = "in data review.st.";
                 break;
          }

          if (limWarnYN == 1){
            limString = limString.fontcolor("blue");
            limWarning = "This term should be applied as a limit in the Ovid interface.";
            limWarning = limWarning.fontcolor("blue");
          }
    }
    //is the term a subset text search?
    else if (limString.search(/\[text/i) >= 0){
        limString = limString.replace(/\[text\]/i,".sb.");
        limString = limString.replace(/"/g,"");
        limString = limString.replace(/jsubset/i,"");
        if (limString.search(/hasabstract/i) >= 0){
          limString = "limit [previous search] to abstracts";
          limString = limString.fontcolor("blue");
          limWarning = "This term should be applied as a limit in the Ovid interface.";
          limWarning = limWarning.fontcolor("blue");
        }
    }


    //package up the results ready to be returned
    limOutputArray[0] = limString;
    limOutputArray[1] = limWarning;
    return limOutputArray;
}

//****************************************************************************************************Filters*******************************************************************

//function formatFilter(filtString) {
    //if (filtString.search(/Publication date/) >= 0){
        //var pdStart = "string";
        //var pdEnd = "Current"
        //filtString = filtString.replace(/Publication date from/"");
        //if (filtString.search(/to/i) >= 0){
            //split the string
        //}
        //else{
            //pdStart = filtString;
       // }
       // if (pdStart.search(/\//) >=0){
            //chop off the month and day
            //make warning that this was done
        //}
       // if (pdEnd.search(/\//) >=0){
            //chop off the month and day
            //make warning that this was done
       // }
       // filtString = "limit [previous line] to (yr=\"" + pdStart + " -" + pdEnd + "\)";
        //return filtString;
    //}
//}


//****************************************************************************************************  Remove Quotes*******************************************************************

function removeQuotesPTO (rqString){
    //check whether the MeSH term contains stop words, remove quotes accordingly
    if (rqString.search(/ and /i) >= 0){
        //do nothing
    }
    else if (rqString.search(/ or /i) >= 0){
        //do nothing
    }
    else if (rqString.search(/ use /i) >= 0){
        //do nothing
    }
    else{
        rqString = rqString.replace(/"/g,"");
    }
    return rqString;
}

//****************************************************************************************************  Subheadings*******************************************************************

function formatSubheadingsPTO (fshString){
    //make a variable to hold any warnings
    var fshWarning = "null";

    //make an array to hold the outputs (string and warnings)
    var fshOutputArray = [null, null];

    //check for retired subheadings
    if (fshString == "diagnostic use"){
        fshWarning = " Diagnostic use is no longer available as a subheading. Subheading removed.";
        fshWarning = fshWarning.fontcolor("red");
    }

   //compare the subheading to a list of all subheadings and convert to Ovid syntax, preserving explosions
    switch (fshString){
        case "analogs and derivatives":
            fshString = "aa";
            break;
        case "abnormalities":
            fshString = "ab";
            break;
        case "administration and dosage":
            fshString = "ad";
            break;
        case "adverse effects":
            fshString = "ae,po,to";
            break;
        case "agonists":
            fshString = "ag";
            break;
        case "anatomy and histology":
            fshString = "ah,bs,cy,em,ir,pa,ul,ab";
            break;
        case "antagonists and inhibitors":
            fshString = "ai";
            break;
        case "analysis":
            fshString = "an,bl,cf,ip,ur";
            break;
        case "biosynthesis":
            fshString = "bi";
            break;
        case "blood":
            fshString = "bl";
            break;
        case "blood supply":
            fshString = "bs";
            break;
        case "cerebrospinal fluid":
            fshString = "cf";
            break;
        case "chemistry":
            fshString = "ch,ag,aa,ai,cs";
            break;
        case "chemically induced":
            fshString = "ci";
            break;
        case "classification":
            fshString = "cl";
            break;
        case "congenital":
            fshString = "cn";
            break;
        case "complications":
            fshString = "co,se";
            break;
        case "chemical synthesis":
            fshString = "cs";
            break;
        case "contraindications":
            fshString = "ct";
            break;
        case "cytology":
            fshString = "cy,pa,ul";
            break;
        case "drug effects":
            fshString = "de";
            break;
        case "deficiency":
            fshString = "df";
            break;
        case "diet therapy":
            fshString = "dh";
            break;
        case "diagnosis":
            fshString = "di,pa,ra,ri,us";
            break;
        case "drug therapy":
            fshString = "dt";
            break;
        case "diagnostic imaging":
            fshString = "dg";
            break;
        case "diagnostic use":
            fshString = "";
            break;
        case "economics":
            fshString = "ec";
            break;
        case "education":
            fshString = "ed";
            break;
        case "ethnology":
            fshString = "eh";
            break;
        case "embryology":
            fshString = "em,ab";
            break;
        case "enzymology":
            fshString = "en";
            break;
        case "epidemiology":
            fshString = "ep,eh,mp";
            break;
        case "ethics":
            fshString = "es";
            break;
        case "etiology":
            fshString = "et,ci,co,cn,em,ge,im,mi,ps,tm,sc,vi";
            break;
        case "growth and development":
            fshString = "gd";
            break;
        case "genetics":
            fshString = "ge";
            break;
        case "history":
            fshString = "hi";
            break;
        case "immunology":
            fshString = "im";
            break;
        case "injuries":
            fshString = "in";
            break;
        case "isolation and purification":
            fshString = "ip";
            break;
        case "innervation":
            fshString = "ir";
            break;
        case "instrumentation":
            fshString = "is";
            break;
        case "legislation and jurisprudence":
            fshString = "lj";
            break;
        case "manpower":
            fshString = "ma";
            break;
        case "metabolism":
            fshString = "me,bi,bl,cf,df,en,pk,ur";
            break;
        case "microbiology":
            fshString = "mi,vi";
            break;
        case "mortality":
            fshString = "mo";
            break;
        case "methods":
            fshString = "mt";
            break;
        case "nursing":
            fshString = "nu";
            break;
        case "organization and administration":
            fshString = "og,ec,lj,ma,st,sd,td,ut";
            break;
        case "pathology":
            fshString = "pa";
            break;
        case "prevention and control":
            fshString = "pc";
            break;
        case "pharmacology":
            fshString = "pd,ad,ae,ag,ai,ct,pk,po,to";
            break;
        case "physiology":
            fshString = "ph,ge,gd,im,me,pp,se,bi,bl,cf,df,en,pk,ur";
            break;
        case "pharmacokinetics":
            fshString = "pk";
            break;
        case "poisoning":
            fshString = "po";
            break;
        case "physiopathology":
            fshString = "pp";
            break;
        case "parasitology":
            fshString = "ps";
            break;
        case "psychology":
            fshString = "px";
            break;
        case "pathogenicity":
            fshString = "py";
            break;
        case "radiography":
            fshString = "dg";
            break;
        case "radiation effects":
            fshString = "re";
            break;
        case "rehabilitation":
            fshString = "rh";
            break;
        case "radionuclide imaging":
            fshString = "dg";
            break;
        case "radiotherapy":
            fshString = "rt";
            break;
        case "secondary":
            fshString = "sc";
            break;
        case "supply and distribution":
            fshString = "sd";
            break;
        case "secretion":
            fshString = "se";
            break;
        case "statistics and numerical data":
            fshString = "sn,ep,sd,ut,eh,mo";
            break;
        case "standards":
            fshString = "st";
            break;
        case "surgery":
            fshString = "su,tr";
            break;
        case "trends":
            fshString = "td";
            break;
        case "therapy":
            fshString = "th,dh,dt,nu,pc,rt,rh,su,tr";
            break;
        case "transmission":
            fshString = "tm";
            break;
        case "toxicity":
            fshString = "to";
            break;
        case "transplantation":
            fshString = "tr";
            break;
        case "therapeutic use":
            fshString = "tu,ad,ae,ct,po";
            break;
        case "ultrastructure":
            fshString = "ul";
            break;
        case "urine":
            fshString = "ur";
            break;
        case "ultrasonography":
            fshString = "dg";
            break;
        case "utilization":
            fshString = "ut";
            break;
        case "veterinary":
            fshString = "ve";
            break;
        case "virology":
            fshString = "vi";
            break;
    }


    //package up the results ready to be returned
    fshOutputArray[0] = fshString;
    fshOutputArray[1] = fshWarning;
    return fshOutputArray;
}


</script>

<!-- Start of StatCounter Code for Default Guide -->
<script type="text/javascript">
var sc_project=11377022;
var sc_invisible=1;
var sc_security="ba30c3ae";
var scJsHost = (("https:" == document.location.protocol) ?
"https://secure." : "http://www.");
document.write("<sc"+"ript type='text/javascript' src='" +
scJsHost+
"statcounter.com/counter/counter.js'></"+"script>");
</script>
<noscript><div class="statcounter"><a title="web stats"
href="http://statcounter.com/" target="_blank"><img
class="statcounter"
src="//c.statcounter.com/11377022/0/ba30c3ae/1/" alt="web
stats"></a></div></noscript>
<!-- End of StatCounter Code for Default Guide -->

</body>
</html>
